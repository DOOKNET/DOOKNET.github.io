<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python学习笔记4]]></title>
    <url>%2F2019%2F01%2F05%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2FPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04%2F</url>
    <content type="text"><![CDATA[python程序设计 文件的应用——写文件将学生的通讯录保存到文件中。 分析：通讯录包括姓名，性别，电话，地址，输入之后，只有存入文件中才能在关机之后仍能保存数据。 1f = open(&apos;contact.txt&apos;,&apos;w&apos;) 文件的应用——读文件将存入文件的通讯录显示出来。 分析：数据一旦存入文件中，就可以 12 文件的基本概念 文件所包含的字节，从文件头到文件结束，位置从0开始。 按文件中数据的组织形式把文件分为两类： 文本文件存储的是常规字符串， 二进制文件 文件的应用——读文件把字符串“a1@中国”写入文件test.txt中，采用GBK编码。显示文件的长度（总字节）。 文件的打开或创建 语法：文件变量名=open(文件名,[打开方式[,缓冲区]]) —文件的读取 语法：read()方法，str=f.read([b]) 参数说明： f：是读取 文件的应用——读文件在相同目录下创建一个test.txt文件，编辑其内容如下： 文件的应用——读二进制文件读取 —文件的遍历 使用in关键字遍历文件中的所有行，方法如下： 文件的应用——遍历读文件—模块 将函数分组，分别放到不同的文件里，提升代码的可维护性和可重用性。 使用模块还可以避免函数名和变量名冲突。 python模块包括内置模块和第三方模块。 在python中，模块是一个.py文件 模块的搜索路径 常用的标准库模块——random12345import sysprint(&quot;共有&quot;,len(sys.argv),&quot;个命令行参数。&quot;);for i in range(0,len(sys.argv)): print(&quot;第&quot;,i+1,&quot;个参数为：&quot;,sys.argv[i])]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记3]]></title>
    <url>%2F2019%2F01%2F05%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2FPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%2F</url>
    <content type="text"><![CDATA[程序设计中的三种基本结构 顺序结构：程序按先后顺序，前一步执行结束之后，才能执行后一步。 选择结构：又称分支结构，指程序流程可以分为几条不同的路径执行。 循环结构：指程序流程重复执行某一项任务。 理解程序设计中的三种基本结构 问题：任意输入三个以逗号分割的数字，按大小顺序输出。 分析：三个数输入后，需要比较两个数字的大小，必要时需要交换两个数字。 12345678910# 数字比较大小s = input(&apos;x,y,z = &apos;)x,y,z = s.split(&apos;,&apos;) #把字符串用逗号进行分离，返回子串构成的列表if x&gt;y: x,y = y,x #交换x,y值if x&gt;z: x,z = z,xif y&gt;z: y,z = z,yprint(x,y,z) 判断输入的数字是否为偶数 输入一个整数，如果是奇数，输出“奇数”，否则输出“偶数” 1234567891011while True: try: num=int(input(&apos;输入一个整数：&apos;)) #判断输入是否为整数 except ValueError: #不是纯数字需要重新输入 print(&quot;输入的不是整数！&quot;) continue if num%2==0: print(&apos;偶数&apos;) else: print(&apos;奇数&apos;) break 程序设计中的循环结构循环结构是一种重复执行的程序结构。 计算1+2+3…+100，这是一个级数求和问题，需要重复执行100次，对100个数依此进行累加 假设1个班级中有n名同学，统计男同学和女同学各有多少名 给定2个整数，求它们的最大公约数和最小公倍数 while循环结构的定义12while 表达式: 循环体 1234while 表达式: 循环体else: else子句 读取整形数值到负数结束从键盘输入若干正整数，求所有输入整数之和。当输入整数为负数时，结束该操作。 分析：由于不确定用户即将输入几个正整数，因此属于不确定循环次数的问题。 12345678# -*- coding: cp936 -*-print(&apos;输入：&apos;)s = 0x = input(&quot;请求输入一个整数：&quot;)while x&gt;=0: s = s+x x = input(&quot;请求输入一个整数：&quot;)print&apos;整数之和=&apos;.s 输出水仙花数输出“水仙花数”，所有水仙花数是指1个3位的十进制制数，其各位数字的立方和等于该数本身。例如：153是水仙花数，因为153=1^3+5^3+3^3 —python函数式编程常用函数——reduce reduce()函数用于将指定序列中的所有元素作为参数按一定的规则调用制定函数。reduce函数的语法如下： 计算结果 = reduce(映射函数,序列) 映射函数的必须有2个参数。reduce()函数首先以序列的第1和第2个元素为参数调用映射函数，然后将返回结果与序列的第3个元素为参数调用映射函数。以此类推，直至应用到序列的最后一个元素，将计算结果作为reduce()函数的返回结果。 —使用序列存储数据简化操作 列表是一种数据结构 sort()是python中的方法，可以对列表中数据排序 序列的定义 序列：一系列按一定顺序排列的数据。 位置编号，也称“下标”或“索引”，是整数或整数表达式。 引用元素：序列名[位置编号]，位置编号从0开始。 序列也可以从尾部访问，最后一个元素是c[-1]。 列表的定义 列表是python中内置数据类型，是数据的有序集合，其中，每一个数据称为元素。 一个列表中的数据类型可以各不相同。 列表中的其所有元素用逗号分割并放在一队中括号“[”“]”中 [10，20，30，40] #所有元素都是整型数据的列表 [‘crunchy frog’,’ram bladder’,’lark vomit’] #所有元素都是字符串的列表 [‘spam’,2.0,5[10,20]] #该列表中包含了一个字符串元素、一个浮点类型元素、一个整型元素和一个列表类型元素 列表的创建和读取 创建列表：使用“=”将一个列表赋值给变量。 读取元素：用变量名加元素序号（放中括号中）即可访问列表中某个元素，列表的第一个元素序号为0。若一个列表有n个元素，则访问元素的合法序号范围是n~n-1。 使用列表进行查询12345678910111213141516171819&gt;&gt;&gt; a_list=[&apos;a&apos;,&apos;b&apos;,&apos;mpilgrim&apos;,&apos;z&apos;,&apos;example&apos;]&gt;&gt;&gt; print(a_list[2])mpilgrim&gt;&gt;&gt; print(a_list[-1])example&gt;&gt;&gt; print(a_list[-5])a&gt;&gt;&gt; print(a_list[-7])Traceback (most recent call last): File &quot;&lt;pyshell#4&gt;&quot;, line 1, in &lt;module&gt; print(a_list[-7])IndexError: list index out of range&gt;&gt;&gt; print(a_list[5])Traceback (most recent call last): File &quot;&lt;pyshell#5&gt;&quot;, line 1, in &lt;module&gt; print(a_list[5])IndexError: list index out of range 列表的切片 切片：可以使用列表序号对来截取列表中的任何部分从而得到一个新列表。序号对中第一个序号表示切片截止（但不包含）位置。 当切片的左索引为0时可缺省，当右索引为列表长度时也可缺省。 使用字典进行查询123456789101112&gt;&gt;&gt; a_list=[&apos;a&apos;,&apos;b&apos;,&apos;mpilgrim&apos;,&apos;z&apos;,&apos;example&apos;]&gt;&gt;&gt; print(a_list[1:3])[&apos;b&apos;, &apos;mpilgrim&apos;]&gt;&gt;&gt; print(a_list[1:-1])[&apos;b&apos;, &apos;mpilgrim&apos;, &apos;z&apos;]&gt;&gt;&gt; print(a_list[:3])[&apos;a&apos;, &apos;b&apos;, &apos;mpilgrim&apos;]&gt;&gt;&gt; print(a_list[3:])[&apos;z&apos;, &apos;example&apos;]&gt;&gt;&gt; print(a_list[:])[&apos;a&apos;, &apos;b&apos;, &apos;mpilgrim&apos;, &apos;z&apos;, &apos;example&apos;] 列表元素的增加 使用“+”将一个新列表附加在原列表的尾部 使用append()方法向列表尾部添加一个新元素 使用extrnd()方法将一个列表添加在原列表的尾部 使用insert()方法将一个元素插入到列表的任意位置 1234567891011121314151617&gt;&gt;&gt; a_list = [1]&gt;&gt;&gt; a_list = a_list + [&apos;a&apos;,2.0]&gt;&gt;&gt; a_list[1, &apos;a&apos;, 2.0]&gt;&gt;&gt; a_list,append(True)&gt;&gt;&gt; a_list.append(True)&gt;&gt;&gt; a_list[1, &apos;a&apos;, 2.0, True]&gt;&gt;&gt; a_list.extend([&apos;x&apos;,4])&gt;&gt;&gt; a_list[1, &apos;a&apos;, 2.0, True, &apos;x&apos;, 4]&gt;&gt;&gt; a_list.insert(0,&apos;x&apos;)&gt;&gt;&gt; a_list[&apos;x&apos;, 1, &apos;a&apos;, 2.0, True, &apos;x&apos;, 4] 列表元素的检索 使用count()方法计算列表中某个元素出现的次数 使用in运算符返回某个元素是否在该列表中 使用index()方法返回某个元素在列表中的准确位置 12345678910111213141516&gt;&gt;&gt; a_list=[&apos;x&apos;,1,&apos;a&apos;,2.0,True,&apos;x&apos;,4]&gt;&gt;&gt; a_list.count(&apos;x&apos;)2&gt;&gt;&gt; 3 in a_listFalse&gt;&gt;&gt; 2.0 in a_listTrue&gt;&gt;&gt; a_list.index(&apos;x&apos;)0&gt;&gt;&gt; a_list.index(5)Traceback (most recent call last): File &quot;&lt;pyshell#17&gt;&quot;, line 1, in &lt;module&gt; a_list.index(5)ValueError: 5 is not in list&gt;&gt;&gt; 列表元素的删除 当向列表中添加或删除元素时，列表将自动拓展或收缩，列表中永远不会有缝隙。 使用del语句删除某个特定位置的元素 使用remove方法删除某个特定值的元素 使用pop(参数)方法来弹出（删除）指定位置的元素，缺省参数时弹出最后一个元素 123456789101112131415161718&gt;&gt;&gt; a_list=[&apos;x&apos;,1,&apos;a&apos;,2.0,True,&apos;x&apos;,4]&gt;&gt;&gt; del a_list[1]&gt;&gt;&gt; a_list[&apos;x&apos;, &apos;a&apos;, 2.0, True, &apos;x&apos;, 4]&gt;&gt;&gt; a_list.remove(&apos;x&apos;)&gt;&gt;&gt; a_list[&apos;a&apos;, 2.0, True, &apos;x&apos;, 4]&gt;&gt;&gt; a_list.remove(&apos;x&apos;)&gt;&gt;&gt; a_list[&apos;a&apos;, 2.0, True, 4]&gt;&gt;&gt; a_list.remove(&apos;x&apos;)Traceback (most recent call last): File &quot;&lt;pyshell#24&gt;&quot;, line 1, in &lt;module&gt; a_list.remove(&apos;x&apos;)ValueError: list.remove(x): x not in list&gt;&gt;&gt; a_list.pop()4 列表中的常用函数 cmp( ) 格式：cmp(列表1,列表2) 功能：对两个列表进行比较，若第一个列表大于第二个，则结果为1，相反则为-1，元素完全相同则结果为0。 len( ) 格式：len(列表) 功能：返回列表中的元素个数 max( )和min() 格式：max(列表)，min(列表) 功能：返回列表中的最大或最小元素 sorted()和reversed() 格式：sorted(列表)，reversed(列表) 功能：前者的功能是对列表的后面增加一个reverse参数，其等于True则表示按降序排列；后者的功能是对列表进行逆序。 sum() 格式：sum() 功能：对数值型列表的元素进行求和运算，对非数值型列表运算则出错。 循环输出列表中元素的值每循环一次输出一个列表元素值，由于列表定义后，其长度是已知的，因此循环次数也是确定的。 1234567891011121314# -*- coding: cp936 -*-a_list=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;]a_len=len(a_list)i=0while i&lt;a_len: print&apos;列表的第&apos;,i+1,&apos;个元素是：&apos;,a_list[i] i +=1 运行结果：列表的第 1 个元素是： a列表的第 2 个元素是： b列表的第 3 个元素是： c列表的第 4 个元素是： d列表的第 5 个元素是： e 列表中元素排序列表Li中有一组单词，把单词分别进行升序排序和降序排序。 应用列表的排序函数sort()能完成升序排序和降序排序。 12345678910111213141516171819# -*- coding: cp936 -*-Li=[&apos;apple&apos;,&apos;peach&apos;,&apos;wps&apos;,&apos;word&apos;,&apos;access&apos;,&apos;excel&apos;,&apos;open&apos;,&apos;seek&apos;]Li2=Li[:]print LiLi.sort() #列表元素按升序排列print&apos;升序：&apos;print Liprint Li2print&apos;降序：&apos;Li2.sort(reverse=True) #列表元素按降序排列print Li2运行结果：[&apos;apple&apos;, &apos;peach&apos;, &apos;wps&apos;, &apos;word&apos;, &apos;access&apos;, &apos;excel&apos;, &apos;open&apos;, &apos;seek&apos;]升序：[&apos;access&apos;, &apos;apple&apos;, &apos;excel&apos;, &apos;open&apos;, &apos;peach&apos;, &apos;seek&apos;, &apos;word&apos;, &apos;wps&apos;][&apos;apple&apos;, &apos;peach&apos;, &apos;wps&apos;, &apos;word&apos;, &apos;access&apos;, &apos;excel&apos;, &apos;open&apos;, &apos;seek&apos;]降序：[&apos;wps&apos;, &apos;word&apos;, &apos;seek&apos;, &apos;peach&apos;, &apos;open&apos;, &apos;excel&apos;, &apos;apple&apos;, &apos;access&apos;] 多维列表 定义一个二维数列表 list2=[[“CPU”,”内存”],[“硬盘”,”声卡”]]; 读取一个二维列表中的元素 列表名[索引1] [索引2] 循环输出列表中元素的值1234567891011list2=[[&quot;CPU&quot;,&quot;内存&quot;],[&quot;硬盘&quot;,&quot;声卡&quot;]];for i in range(len(list2)): list1=list2[i]; for j in range(len(list1)): print(list1[j])运行结果：CPU内存硬盘声卡 —元组 元组和列表类似，但其元素是不可变的，元组一旦创建，用任何方法都不可修改其元素。 元组的定义方式和列表相同，但定义时所有元素是放在一对圆括号“(”和“)”中，而不是方括号中。 下面这些都是合法的元组：(10,20,30,40)(‘crunchy frog’,’ram bladder’,’lark vomit’) 元组的操作 创建元组：使用“=”将一个元组赋值给变量。 读取元素 元组切片 列表元素的排序 元组的检索 检索元素 使用count( )方法计算元组中某个元素出现的次数 元组元素的排序 元组与列表的区别 元组中的数据一旦定义就不允许更改。因此，元组没有append()或extend()方法， 利用元组来一次性对多个变量赋值12345678&gt;&gt;&gt; v_tuple = (False,3.5,&apos;exp&apos;)&gt;&gt;&gt; (x,y,z) = v_tuple&gt;&gt;&gt; xFalse&gt;&gt;&gt; y3.5&gt;&gt;&gt; z&apos;exp&apos; —字典 字典是键值对的无序集合。 字典中的每个元素包含两部分：键和值。向字典添加一个键的同时，必须为该键增添一个值。 字典的创建和查找 创建字典 字典定义后 遍历字典 123&gt;&gt;&gt; a_dict = &#123;&apos;server&apos;:&apos;db.diveintopython3.org&apos;,&apos;database&apos;:&apos;mysql&apos;&#125;&gt;&gt;&gt; a_dict&#123;&apos;database&apos;: &apos;mysql&apos;,&apos;server&apos;:&apos;db.diveintopython3.org&apos;&#125; 使用字典进行查询 字典的更新 添加和修改字典 字典没有预定义的大小限制。 可以随时向字典中添加新的键值对，或者修改现有键所关联的值。 添加和修改的方法相同，都是使用“字典变量名[键名]=键值”的形式，区分究竟是添加还是修改是看键名与字典中现有的键名是否重复，因为字典中不允许有重复的键。如不重复则是添加新键值对，如重复则是将该键对应的值修改为新值。 12 字典的其它操作 字典的长度 与列表、元组类似，可以用len()函数返回字典中键的数量。 字典检索 删除元素和字典 12 列表作为函数参数12345678910111213141516def sum(list): total = 0; for x in range(len(list)): print(list[x],&quot;+&quot;); total+=list[x]; print(&quot;=&quot;,total);list = [15,25,35,65]sum(list);#运行结果==========RESTART:E:\Workspace\Python_2.7\2018_8_22_Test\test.py==========(15, &apos;+&apos;)(25, &apos;+&apos;)(35, &apos;+&apos;)(65, &apos;+&apos;)(&apos;=&apos;, 140) 123456789101112def print_dict(dict): for(k,v) in dict.items(): print&quot;dict[%s]=&quot;%k,vdict = &#123;&quot;a&quot;:&quot;apple&quot;,&quot;b&quot;:&quot;banana&quot;,&quot;g&quot;:&quot;grape&quot;,&quot;o&quot;:&quot;orange&quot;&#125;print_dict(dict);#运行结果========== RESTART:E:\Workspace\Python_2.7\2018_8_22_Test\test.py==========dict[a]= appledict[b]= bananadict[o]= orangedict[g]= grape 函数中修改列表参数 函数中修改字典参数 集合的创建和访问12 集合元素的增加 集合元素的删除1234567&gt;&gt;&gt; s = set([1,2,3])&gt;&gt;&gt; s.remove(1)&gt;&gt;&gt; print(s)set([2, 3])&gt;&gt;&gt; s.clear()&gt;&gt;&gt; print(s)set([]) 集合的运算子集和超集12 —复杂的数据结构 在解决实际问题时，还经常需要用到其他复杂的数据结构，如堆、栈、队列、树、图等。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记2]]></title>
    <url>%2F2019%2F01%2F05%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2FPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%2F</url>
    <content type="text"><![CDATA[IDLE中调试程序 使用IDLE打开源文件，点击”run module =&gt; debug =&gt; debugger”打开调试器窗口。 切换到调试器窗口进行调试。 IDLE中调试窗口 IDLE中的菜单 python中的文件名 py：编写python代码时，得到的是一个以.py为扩展名的文本文件。 .pyo：优化的python字节码文件，同样无法使用文本编辑器直接查看其内容。可以使用“python-o-m py_compile file.py”或“python-oo-m py_compile file.py”进行优化编译。 .pyd：一般是由其他语言编写并编译的二进制文件，常用于实现某些软件工具的python编程接口插件或python动态链接库。 python的解释器 Cpython是安装好python2.7后，获得的官方版本的解释器，是用C语言开发的。 IPython是基于Cpython的交互式解释器，即，Ipython在交互方式上有所增强，在执行python代码的功能和CPython是完全一样的。 PyPy采用JIT技术，对python代码进行动态编译（注意不是解释），所有可以显著提高python代码的执行速度。 Jython是运行在Java平台上的python解释器，可以直接把python代码编译成Java字节码执行。 IronPython和Jython类似，但是其运行在微软.Net平台上，可以直接把python代码编译成.Net的字节码。 python脚本中的import 导入模块：模块为一个文件，可以作为模块的文件类型包括“.py”、“.pyo”、“.pyc”、“.pyd”、“.so”、“.dll”等。 导入包：包是一个目录，使用import导入包，或者from+import来导入包中的部分模块。包目录下包括文件init.py和模块文件、子目录，如果子目录中也有init.py。那么它就是这个包的子包。 python脚本中的import的例子123456&gt;&gt;&gt;import math&gt;&gt;&gt;math.sin(0.5) #求0.5的正弦&gt;&gt;&gt;import random&gt;&gt;&gt;x=random.random() #获得[0,1)内的随机小数&gt;&gt;&gt;y=random.random()&gt;&gt;&gt;n=random.randint(1,100) #获得[1,100]上的随机整数 python中包管理工具 easy_install： 位于C:\Python27\Scripts easy_install pip,开始安装pip pip： pip是一个安装和管理Python包的工具，方便地下载Python包。 不仅下载需要的包，而且会下载依赖包。 pip install包名称 python脚本中的输入和输出输入 输入是通过raw_input( )或input( )函数来实现的，input( )的一般格式为： x = input(“提示：”) 该函数返回输入的对象。可输入数字、字符串和其他对象。 raw_input( )直接读取控制台的输入（任何类型的输入它艘都可以接收）。面对于input( )，它希望能够读取一个合法的python表达式，即你输入字符串的时候必须使用引号将它括起来，否则它会引发一个SyntaxError。 输出 输出是通过print语句来完成的，一般格式为： print 对象1，对象2…对象n print (字符串常量或字符串变量) print (“ %s%s_”%(string1,string2,_stringn)) print (“ %d%d_”%(整数1,整数2,整数n)) print (“ %x,%o”%(255,255)) python脚本中的输入和输出的例子123456789101112&gt;&gt;&gt; raw_input_A = raw_input(&quot;raw_input:&quot;)raw_input:abc&gt;&gt;&gt; input_A = input(&quot;Input:&quot;)Input:abcTraceback (most recent call last): File &quot;&lt;pyshell#20&gt;&quot;, line 1, in &lt;module&gt; input_A = input(&quot;Input:&quot;) File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt;NameError: name &apos;abc&apos; is not defined&gt;&gt;&gt; input_A = input(&quot;Input:&quot;)Input:&quot;abc&quot; 123456&gt;&gt;&gt; print 300300&gt;&gt;&gt; print 100 + 200300&gt;&gt;&gt; print&apos;100 + 200 =&apos;,100 + 200100 + 200 = 300 python程序的性能测试内存占用测试1234567891011from memory_profiler import profile@profiledef ifPrime(n): if n == 2: return True for i in range(2,int(n**0.5)+2): if n%i == 0: return False return TureisPrime(9999999999999999999) python的对象模型 计算机能处理的远不止数值，还可以处理文本、图形、音频、视频、网页等各种各样的数据，不同的数据，需要定义不同的数据类型。 在python中，一切事物都是对象，程序中存储的所有数据都是对象，对象基于类创建。 class 指自定义类型，type 指内置类型。 实例化：创建特定类型的对象，实例被创建后，其身份和类型不可改变。 若对象值可修改，称为可变对象 若对象值不可修改，称之为不可变对象 容器：某个对象包含对其他对象的引用，如：列表 python数据类型 python数据类型的例子 对象类型 例子 数字 1234，3.14，3+4j 字符串 ‘swfu’，”I’m student”，”Python” 日期 2012-08-25 列表 [1,2,3] 字典 {1:’food’,2:’taste’,3:’import’} 元组 (2,-5,6) 文件 f=open(‘data.dat’,’r’) 集合 set(‘abc’),{‘a’,’b’,’c’} 布尔型 True,False 空类型 None 编程单元类型 函数、模块、类 数字常量 浮点数又称小数，如15.0、0.37、-11.2、1.2e2、314.15e-2 复数是由实部和虚部构成的数，如3+4j、0.1-0.5j 123456789&gt;&gt;&gt; a=3+4j&gt;&gt;&gt; b=5+6j&gt;&gt;&gt; c=a+b&gt;&gt;&gt; c(8+10j)&gt;&gt;&gt; c.real #复数的实部8.0&gt;&gt;&gt; c.imag #复数的虚部10.0 布尔类型 在计算机语言中表达两种相反的结果，把结果肯定的用“True”表示，把结果否定的用“False”来表示。 布尔类变量只有二种可能值：True或者False 12b = 100&lt;101print(b) b是布尔类型变量，运行此段程序，将输出True 字符串 用单引号或双引号括起来的符号系列称为字符串，如’abc’、’123’、’中国’、”Python” 空串表示为’’或”” 转义字符可表示特殊字符，如’\n’是换行符、’\x41’、’\101’、’A’都表示字符A 三引号表示的字符串可以换行，因此可以用来表示超长字符串，或给程序加较长的注释。 字符串的下标字符串中字符的位置从左到右以下标0开始，从右到左以下标-1开始。 S T F D E N O X Y Z 0 1 2 … … … … … -2 -1 12345&gt;&gt;&gt; a=&quot;hello&quot;&gt;&gt;&gt; a[0]&apos;h&apos;&gt;&gt;&gt; a[-1]&apos;o&apos; 字符串的截取截取有两种方法： 一种是索引 s[index]，取出一个字符； 另一种是切片 s[[start]:[end]]，取出多个字符 123456789&gt;&gt;&gt; s = &apos;abcdef&apos;&gt;&gt;&gt; s[1:3] #取出位置为1到位置为2的字符，不包括3&apos;bc&apos;&gt;&gt;&gt; s[:3] #取出从头至位置2的字符&apos;abc&apos;&gt;&gt;&gt; s[4:] #取出从位置4开始的所有字符&apos;ef&apos;&gt;&gt;&gt; s[:] #取出全部字符&apos;abcdef&apos; 字符串的查找在字符串中查找一个子串，返回子串的位置，成功返回下标，失败返回-1 语法格式为： s.find(sub[,start][,end]) 12345&gt;&gt;&gt; s = &apos;apple,peach,banana,peach,pear&apos;&gt;&gt;&gt; s.find(&apos;peach&apos;,7)19&gt;&gt;&gt; s.find(&apos;peach&apos;,7,20)-1 字符串的分割通过指定分隔符对字符串进行分割，返回分割后的字符串列表 语法格式为： str.split(str = “”,num = string.count(str)) 参数： str：分隔符，默认所有的空格符，包括空格、换行(\n)、制表符(\t)等 num：分割次数 1234&gt;&gt;&gt; s = &apos;apple,peach,banana,pear&apos;&gt;&gt;&gt; li = s.split(&apos;,&apos;)&gt;&gt;&gt; li[&apos;apple&apos;, &apos;peach&apos;, &apos;banana&apos;, &apos;pear&apos;] 字符串的连接将序列中的元素以制定的字符连接生成一个新的字符串 语法格式为： str.join(sequence) 参数：要连接的元素列表 12345&gt;&gt;&gt; li = [&apos;apple&apos;,&apos;peach&apos;,&apos;banana&apos;,&apos;pear&apos;]&gt;&gt;&gt; sep = &apos;,&apos;&gt;&gt;&gt; s = sep.join(li)&gt;&gt;&gt; s&apos;apple,peach,banana,pear&apos; 字符串的转换小写字母转换字符串中所有大写字符为小写 语法格式为： str.lower( ) 参数：无 返回将字符串中所有大写字符转化为小写后生成的字符串 1234&gt;&gt;&gt; s=&quot;What&apos;s Your Name?&quot;&gt;&gt;&gt; s2=s.lower()&gt;&gt;&gt; s2&quot;what&apos;s your name?&quot; 字符串的替换把字符串中的old（旧字符串）替换成new（新字符串） 语法格式： str.replace(old,new[,max]) 参数： old：将被替换的子字符串 new：新字符串，用于替换old子字符串 max：可选字符串，替换不超过max次 123456&gt;&gt;&gt; s = &apos;hello world&apos;&gt;&gt;&gt; print shello world&gt;&gt;&gt; s2 = s.replace(&apos;hello&apos;,&apos;hi&apos;)&gt;&gt;&gt; print s2hi world 字符串两端删除字符移除字符串头尾指定的字符（默认为空格） 语法格式为： str.strip([chars]) 参数： chars：移除字符串头尾指定的字符 返回移除字符串头尾指定的字符生成的新字符串 1234&gt;&gt;&gt; s = &apos;abc &apos;&gt;&gt;&gt; s2 = s.strip()&gt;&gt;&gt; s2&apos;abc&apos; 字符串结束符判断判断字符串是否以指定后缀结尾，如果以指定后缀结尾，返回True，否则返回False 语法格式为： str.endswith(suffix[,start[,end]]) 参数： suffix：一个字符串或者是一个元素 start：字符串中的开始位置 end：字符中结束位置 12345678910&gt;&gt;&gt; str=&quot;this is a car!!!&quot;&gt;&gt;&gt; suffix=&quot;car!!!&quot;&gt;&gt;&gt; print str.endswith(suffix)True&gt;&gt;&gt; suffix=&quot;is&quot;&gt;&gt;&gt; print str.endswith(suffix,2,4)True&gt;&gt;&gt; str=&quot;this is a car!!!&quot;&gt;&gt;&gt; print str.endswith(suffix,2,4)True 常用字符串处理函数检测字符串是否由字母和数字组成 语法格式： str.isalnum( ) 参数：无 如果string至少有一个字符并且所有字符都是字母或数字则返回True，否则返回Flase 12345&gt;&gt;&gt; str=&quot;time1125&quot;&gt;&gt;&gt; print str.isalnum()True&gt;&gt;&gt; str=&quot;time1125!&quot;&gt;&gt;&gt; print str.isalnum() 函数 描述 string.count(str,beg=0,end=len(string)) 返回str在string里面出现的次数 string.isdigit() 如果string只包含数字则返回True否则返回False max(str) 返回字符串str中最大的字母 min(str) 返回字符串str中最小的字母 string.rfind(str,beg=0,end=len(string)) 类似于find()函数，不过是从右边开始查找 string.rindex(str,beg=0,end=len(string)) 类似于index()函数，不过是从右边开始查找 string.startswith(obj,beg=0,end=len(string)) 返回字符串是否是以.obj开头，是则返回True，否则返回False。如果返回False和end指定值，则在指定范围内检查 字符串使用的案例题目：用户输入数字，用逗号分隔，使用python编程求这些数字的和。 分析：用户输入的数字个数是不确定的，可以当作一个字符串来处理。首先，分割数字串，然后，将子串转换成数字，最后，将数字求和。 123456789101112s=raw_input(&apos;Input Numbers separated by comma: &apos;)li=s.split(&apos;,&apos;)print lisum=0for x in li: sum=sum+float(x)print&apos;sum=&apos;,sum运行结果为：Input Numbers separated by comma: 23,2,5,12.3[&apos;23&apos;, &apos;2&apos;, &apos;5&apos;, &apos;12.3&apos;]sum= 42.3 字符串转化为数字 将字符串转化为整数，语法如下： int(x [,base])，参数x是待转换的字符串，参数base为可选参数，指定转换后整数的进制，默认为10进制。 将字符串转化为长整数，语法如下： long(x[,base])，参数的含义与int()函数相同。 将字符串或数字转化为浮点数，语法如下： float(x)，参数x是待转换的字符串或数字。 计算字符串中的有效python表达式，并返回结果。 12345678&gt;&gt;&gt; a=&quot;1&quot;&gt;&gt;&gt; b=int(a)+1&gt;&gt;&gt; print b2&gt;&gt;&gt; &gt;&gt;&gt; b=&quot;1+2&quot;&gt;&gt;&gt; print(eval(b))3 转化为字符串 将数值转化为字符串，语法如下： str(x)，参数x是待转换的数值 将对象转化为可打印字符串，语法如下： repr(obj)，参数obj是待转换的对象 将一个整数转化为可对应ASCII的字符，语法如下： chr(整数) 将一个字符转化为可对应ASCII的字符，语法如下： ord(字符) 将一个整数转化为一个十六进制字符串，语法如下： chr(整数) 将一个整数转化为一个八进制字符串，语法如下： oct(字符) —变量 变量存储在内存中的值。这就意味着在创建变量时会在内存中开辟一个空间。与常量不同的是变量的值可以动态变化。 基于变量的数据类型，解释器会分配制定内存，并决定什么数据可以被存储在内存中。 变量可以指定不同的数据类型，这些变量可以存储整数，小数或字符。 变量的命名规则 python的变量命名规则如下： 标识符名字的第一个字符必须是字母或下划线(_)； 标识符名字的第一个字符后面可以由字母、下划线(_)或数字(0~9)组成； 标识符名字是区分大小写的。 变量的赋值 每个变量在内存中创建，都包括变量的标识，名称和数据这些信息。 每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。 等号（=）用来给变量赋值。等号（=）运算符左边是一个变量名，等号（=）运算符右边是存储在变量中的值 变量的例子定义了一个字符串变量a、数值变量b和布尔类型变量c 123a=&quot;This is a String&quot;b=2c=True 多个变量的赋值 创建一个整形对象，值为1，三个变量被分配到相同的内存空间 123&gt;&gt;&gt; a=b=c=1&gt;&gt;&gt; print a,b,c1 1 1 两个整型对象1和2的分配给变量a和b，字符串对象“iohn”分配给变量c 123&gt;&gt;&gt; a,b,c=1,2,&quot;john&quot;&gt;&gt;&gt; print a,b,c1 2 john 变量的引用 引用：在python中从变量到对象的连接称为引用。 变量拥有自己的存储空间，变量连接到对象是该变量存储了对象单元的内存地址，并没有存储对象的值。 变量的共享引用共享引用是指多个变量引用同一个对象。下面的语句使两个变量都引用同一个对象3。12&gt;&gt;&gt; a=3&gt;&gt;&gt; b=a 删除对象引用使用del语句删除对象的引用，语法格式为： del varl[,var2[,var3[…,varN]]] 123456789101112&gt;&gt;&gt; a=5&gt;&gt;&gt; b=a&gt;&gt;&gt; print a,b5 5&gt;&gt;&gt; del b&gt;&gt;&gt; print a,b5Traceback (most recent call last): File &quot;&lt;pyshell#5&gt;&quot;, line 1, in &lt;module&gt; print a,bNameError: name &apos;b&apos; is not defined —python的运算符 运算符是可以操纵操作数值的结构。 运算符是程序设计语言的最基本元素，它是构成表达式的基础。 如在10+20=30中，10和20称为操作数，+称为运算符。 python运算符的分类 算数运算符 赋值运算符 位运算符 比较运算符 逻辑运算符 字符串运算符 成员运算符 身份运算符 python中的算数运算符 算数运算符 描述 例子 + 相加运算 1+2的结果是3 - 相减运算 100-1的结果是99 * 乘法运算 2*2的结果是4 / 除法运算 4/2的结果是2 % 求模运算 10%3的结果是1 ** 幂运算，x**y返回x的y次幂 2**3的结果是8 // 整除运算，返回商的整数部分 9//2的结果是4 python中的赋值运算符 赋值运算符 描述 例子 = 直接赋值 x=3，将3赋值到变量x中 += 加法赋值 x+=3，等同于x=x+3 -= 减法赋值 x-=3，等同于x=x-3 *= 乘法赋值 x=3，等同于x=x3 /= 除法赋值 x/=3，等同于x=x/3 %= 取模赋值 x%3，等同于x=x%3 **= 幂赋值 x=3，等同于x=x3 //= 整除赋值 x//=3，等同于x=x//3 python中的位运算符 位运算符 描述 &amp; 按位与运算。相当于”*”；都是1则为1，否则为0 \ 按位或运算。相当于”+”；都是0则为0，否则为1 ^ 按位异或运算。0^0=0;1^0=1;0^1=1;1^1=0 ~ 按位非运算 &lt;&lt; 位左移运算，即所有位左移 &gt;&gt; 位右移运算，即所有位向右移 python中的比较运算符 比较运算符 描述 = 等于运算符。返回True或False != 不等运算符。返回True或False &lt;&gt; 不等运算符，与!=相同 &lt; 小于运算符 &gt; 大于运算符 &lt;= 小于等于运算符 &gt;= 大于等于运算符 python中的逻辑运算符 逻辑运算符 描述 and 逻辑与运算符。例如：a and b，当a和b都为True时等于True；否则等于False or 逻辑或运算符。例如：a or b，当a和b至少有一个为True时等于True；否则等于False not 逻辑非运算符。例如：not a，当a等于True时，表达式等于False；否则等于True python中的字符串运算符 字符串运算符 描述 + 字符串连接 * 重复输出字符串 [] 获取字符串中指出索引位置的字符，索引从0开始 [start,end] 截取字符串中的一部分，从索引位置start开始到end结束 in 成员运算符，如果字符串中包含给定的字符则返回True not in 成员运算符，如果字符串中不包含给定的字符返回True r或者R 指定原始字符串。原始字符串是指所有的字符串都是直接按照字面意思来使用，没有转义字符、特殊字符或不能打印的字符。原始字符串的第一个引号前加上字母“r”或“R” python中的字符串运算符的例子12345b = &quot;hello&quot;;a = b + &quot;world!&quot;;print(a);print(a*2);print(r&quot;hello\nworld!&quot;); python中成员和身份运算符 成员运算符 描述 in 如果在指定的序列中找到值返回True，否则返回False not in 如果在指定的序列中没有找到值返回True，否则返回False 身份运算符 描述 is is 是判断两个标识符是不是引用自一个对象 is not is not 是判断两个标识符是不是引用自不同对象 python中的运算符优先级 运算符 描述 ** 指数运算的优先级最高 ~、+、- 逻辑非和正/负运算符。注意这里的“+”“-”不是加减运算符 *、/、%、// 乘、除、取模、取整除 +、- 加和减 &gt;&gt;、&lt;&lt; 位右移运算和左移运算 &amp; 按位与运算 ^、\ 按位异或和按位或运算 &gt;、==、!= 大于、等于、不等于 %=、/=、//=、-=、+=、=、*= 赋值运算符 is、is not 身份运算符 in、not in 成员运算符 not、or、and 逻辑运算符 —python中的表达式的分类 表达式 描述 x+y、x-y 加法减法 x*y、x/y、x//y、x%y 乘法/重复，除法，求整商，余数/格式化 x**y 幂运算 x&lt;y、x&lt;=y、x&gt;y、x&gt;=y 大小比较，集合的包含关系比较 x==y、x!=y 相等比较，不等比较 x or y 逻辑或（只有x为假才会计算） x and y 逻辑与（只有x为真才会计算） not x 逻辑非 x in y、x not in y 成员与集合的关系 x is y、x is not y 对象实体测试 python中的逻辑组合表达式成绩score在90~100或者50~60之间 90 &lt;= score &lt;= 100 or 50 &lt;= score &lt;= 60 —python中的语句 语句是一段可执行代码，不一定有返回值。 语句块是一组语句： 通过放置空格来缩进语句创建语句块，语句块中的每一行必须是同样的缩进量。 Python语言利用缩进表示语句块的开始和退出（Off-side规则），而非使用花括号或者某种关键字。 增加缩进表示语句块的开始，而减少缩进则表示语句块的推出。 python中的赋值语句 赋值语句是python中最简单、最常用的语句。 通过赋值语句可以定义变量并为其赋初始值。 Python中创建一个变量，不需要声明其类型。 python中的序列赋值语句可以把赋值运算符右侧的一系列值，依次赋给左侧的变量。 1234567891011121314a,b=4,5print(a,b)a,b=(6,7)print(a,b)a,b=&quot;AB&quot;print(a,b)((a,b),c)=(&apos;AB&apos;,&apos;CD&apos;) #嵌套序列赋值print(a,b,c)运行结果：(4, 5)(6, 7)(&apos;A&apos;, &apos;B&apos;)(&apos;A&apos;, &apos;B&apos;, &apos;CD&apos;) python中的扩展序列赋值语句在序列赋值中，赋值运算符左侧的变量个数和右侧值的个数总是相等的。如果不相等，Python就报错。Python中使用带有星号的名称，如*j，实现了扩展序列赋值。 12345i,*j=range(3)print(i,j)运行结果：0,[1,2] python中的增强赋值语句增强赋值语句是从C语言借鉴而来，实质上是基本赋值语句的简写。通常来说，增强赋值语句的运行会更快一些。将变量x增加y赋给变量x，基本赋值语句为： x = x+y 增强赋值语句则为： x+=y 相应的，还有：+=、*=、-=等 python中的条件语句条件语句是根据条件表达式的值是True/非零还是False/零做出决策，控制代码块的执行。 python中的条件语句中的逻辑判断类型 两个对象之间的关系：==、!=、&lt;、&gt;、&gt;=、&lt;= 注：!=还可以表示成：&lt;&gt; 成员测试：in、not in python中的断言语句 在没完善一个程序之前，不知道程序在哪里会出错，与其让它在运行时崩溃，不如在出现错误条件时就崩溃，这时候就需要assert断言语句。 断言语句的语法是： assert expression[,reason] 当判断表达式expression为真时，什么都不做；如果表达式为假，则抛出异常。 assert语句一般用于开发程序时对特定必须满足的条件进行验证，仅当debug为True时有效。当Python脚本以-o选项编译为字节码文件时，assert语句将被移除以提高运行速度。 python中的上下文管理语句 使用with自动关闭资源，可以在代码块执行完毕后还原进入该代码块时的现场。 无论何种原因跳出with块，无论是否发生异常，总能保证文件被正确关闭，资源被正确释放。 with语句的语法如下： with context_expr[as var]: with块 python中的异常语句 当python检测到一个错误时，解释器就会指出当前流已无法继续执行下去，这时候就出现了异常。异常是指因为程序出错而在正常控制流以外采取的行为。 异常分为两个阶段：第一阶段是引起异常发生的错误；第二阶段是检测并处理阶段。 python中的内置异常 异常类名 描述 Exception 所有异常的基类 NameError 尝试访问一个没有声明的变量 ZeroDivisionError 除数为0 SyntaxError 语法错误 IndexError 索引超出序列范围 KeyError 请求一个不存在的字典关键字 IOError 输入输出错误（比如你要读的文件不存在） AttributeError 尝试访问未知的对象属性 ValueError 传给函数的参数类型不正确 EOFError 发现一个不期望的 python中的捕获异常 try子句中的代码块放置可能出现异常的语句，except子句中的代码块处理异常。 捕获异常的例子12345678&gt;&gt;&gt; a_list=[&apos;China&apos;,&apos;America&apos;,&apos;England&apos;,&apos;France&apos;]&gt;&gt;&gt; try: print a_list[4]except IndexError: print&apos;列表元素的下标越界&apos;运行结果是：列表元素的下标越界 引入循环结构，可以实现重复输入字符串序号，直到检测序号不越界而输出相应的字符串。123456789101112131415a_list=[&apos;Chian&apos;,&apos;America&apos;,&apos;England&apos;,&apos;France&apos;]print&apos;请输入字符串的序号&apos;while True: n=input() try: print a_list[n] except IndexError: print&apos;列表元素的下标越界，请重新输入字符串的序号&apos; else: break;运行结果：请输入字符串的序号1America python中的捕获所有异常任何情况下都需要执行的语法格式：1234try: ...finally: ... #无论如何都会执行]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记1]]></title>
    <url>%2F2019%2F01%2F05%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2FPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[1. 比较重要的点 基本语法 掌握爬虫 编译性语言写的程序需要从源文件转换到二进制代码，这个过程通过编译器完成。计算机可以直接以机器语言来运行程序，速度快。 解释型语言： 强数据类型的语言： 弱数据类型 python与C语言 python与Java语言 python的发展历史 编程语言排行 python的特点： 简单易学 开源免费 高级语言，解释型语言 可移植性高。。。 python可以做什么 网络编程：python包含标准。。。 数据库编程：支持主流数据库。。。 数据分析：NumPy扩展。。。 人工智能：PyRO进行机器控制。。。 游戏开发： python应用 python成为人工智能的首选语言 python已经是数据分析和人工智能的第一语言，网络攻防的第一黑客语言，正在成为编程入门教学的第一语言，云计算系统管理第一语言。 python开发版本的选择 2.7.x]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown手册]]></title>
    <url>%2F2018%2F08%2F29%2F%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0%2FMarkdown%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[Markdown扩展安装： markdownlint 用于检查markdown样式是否规范，如果不符合规范会有相应提示。 Markdown PDF 用于将Markdown文档打印成PDF。只需要在编辑时点击任意位置右键选择相应的打印选项即可。 Markdown Table Prettifier 用于将表格排列整齐。在编辑的表格处右键，选择“格式化文件”即可将表格排列整齐。 Markdown All in One 集成多种功能于一体，可以替代上面几种扩展。 Markdown基本语法： 标题 语法：123# 一级标题## 二级标题### 三级标题 引用 语法：1&gt; 引用的内容 代码段 语法：123三个&quot;`&quot;代码段三个&quot;`&quot; 表格 语法：123|表头|表头||--- |---||内容|内容| 插入网页链接 语法：1[网站名称](网址) 插入图片 语法：1![图片描述](图片链接) Markdown编辑公式：没有安装“Markdown All in One”这个扩展时，需要先在文件中添加以下代码才能显示出公式。1&lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default&quot;&gt;&lt;/script&gt;]]></content>
      <categories>
        <category>应用笔记</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OneNote使用笔记]]></title>
    <url>%2F2018%2F04%2F23%2F%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0%2FOneNote%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言：之前很长一段时间用OneNote记笔记，但是发现它的同步是个问题，老是同步出错，也一直解决不了。后来慢慢开始用有道云笔记记东西（主要是能写markdown），然后OneNote搁置到现在。 最近突然又想用OneNote来记东西了（主要是因为颜值高，真心觉得有道云笔记太丑了，奈何我又是颜控），虽然同步有问题，但把笔记写在本地，不用同步，体验还是不错的。下面主要是我在使用过程中遇到的问题。 1. 关于OneNote不同版本的问题目前我电脑里有两个版本的OneNote，一个是win10自带的OneNote，另一个是OneNote 2016. 简单来说，自带的OneNote功能相对少一些，但也是够用的。只有在某些场合下功能受限，比如：新建笔记本等。 就我个人而言，更喜欢自带的OneNote，整个UI风格，交互设计可以说是非常符合我的口味。而OneNote 2016的界面和word很像，整体来说也还是不错的。 2. 如何新建笔记本如上面所说，新建笔记本这个操作在自带的OneNote里是不能实现的，需要用OneNote 2016来实现。 笔记本一共有两种，一种是云端笔记本，另一种是本地笔记本。 新建云端笔记本 【文件 — 新建 — OneDrive-个人】 新建本地笔记本 【文件 — 新建 — 这台电脑】 3. 如何同步本地笔记本在【文件 — 信息】里找到要同步的本地的笔记本，点击旁边的【设置 — 共享或移动】，就能把本地笔记本搬移到云端，这里需要注意的是搬移到云端的笔记本和本地笔记本虽然名字一样但已经没有关系了，属于两个独立的笔记本了。 另外说一下如何区分云端和本地的笔记本，如下图： 4. 如何删除笔记本和新建笔记本一样，分为云端和本地两种 删除云端笔记本 这个操作并不能在软件里实现，需要配合网页的云端进行。 简单来说，先登陆网页版的OneDrive，删除选择的笔记本，然后在客户端【文件 — 信息 — 设置】里点击关闭。这时候你再【打开】笔记本你会发现原笔记本已经没有了。（这两者的先后顺序不影响） 删除本地笔记本 和云端的操作类似，先在本地把对应笔记本的文件夹删除，一般在【C:\Users\用户名\Documents\OneNote 笔记本】下，然后再点击【关闭】对应的笔记本。 嗯，就酱！]]></content>
      <categories>
        <category>应用笔记</category>
      </categories>
      <tags>
        <tag>OneNote</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于乘法器的那些事]]></title>
    <url>%2F2018%2F02%2F26%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F%E5%85%B3%E4%BA%8E%E4%B9%98%E6%B3%95%E5%99%A8%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[一、整数乘法器1.1 整数的概念整数在IEEE的规定上有，短整数 short integer ，中整数 integer 和 长整数 long integer ，他们之间的关系如下： 整数 字节空间 取值范围 短整数 一个字节 -127 ~ 127 整数 二个字节 -32767~32767 长整数 四个字节 -2147483647~2147483647 若无特殊说明，以下都以短整数举例。 四个结论： 短整数的最高位是符号位，正值的符号位是“0”，负值的符号位是“1”。 正值用原码表示，负值用补码表示。 正值(8’b0000_0100)“取反加一”就得到负值(8’b1111_1100) ； 同理，负值(8’b1111_1100)“取反加一”就得到正值(b’b0000_0100)。 8’b1000_0000既不是正数也不是负数也不是0，它是划分正值和负值的边界线。 12345+4 即 8&apos;b0000_0100;+127 即 8&apos;b0111_1111;分界线 8&apos;b1000_0000;-127 即 8&apos;b1000_0001;-4 即 8&apos;b1111_1100; 1.2 传统乘法器在传统概念上，乘法等价于“重复几次”，也就是累加操作。比如：B=4,那么A x B等价于A重复加四次。那如果B=-4应该怎么理解呢？先来看一组例子：12345A x B = C；3 x 4 = 12;-3x 4 = -12;3 x-4 = -12;-3x-4 = 12; 其中，C的值可以看成由两部分构成：正负和数值。 撇开正负不看，乘积的数值就是A和B绝对值相乘的结果。那么乘积的正负如何确定呢？ 其实正负号的运算规则和数字电路中的“异或运算”一样。 A B C(A⊕B) 0 0 0 0 1 1 1 0 1 1 1 0 其中，0表示正号，1表示负号。 因此，传统乘法器实现的大致操作如下： 在初始化之际，取乘数和被乘数的正负关系,然后取乘数和被乘数的正值。 每一次累加操作，递减一次乘数。直到乘数的值为零，表示操作结束。 输出结果根据正负关系取得。 其实传统的乘法器是很容易的，但是随着整数的出现，负值和正值也随着出现，这也使得设计多了一点难度。但是只要掌握负值和正值的关系以后，乘法只作正值也“无问题” ，只要在结果输出之前“下一点手脚”就行了。 1.3 传统乘法器的改进传统的乘法器虽然简单，但是它有一个致命的问题。就是被乘数越大就越消耗时钟。那么要解决这个问题就要了解为什么会产生这个问题。还是举例来说： 假设A=10 , B=20 , A x B ，那么时钟的消耗至少需要 20个，因为A值需要累加20次才能得到结果。回顾一下乘法法则：A x B = B x A。如果以B作为基础，那么B值只需要累加10次就能得到结果，这样就可以节省时钟的消耗。 因此我们可以这样改进：在进行累加操作之前，增加一个比较步骤。如果被乘数小于乘数，那么被乘数和乘数互换。1&#123;Multiplier , Multiplicand&#125; = Multiplicand &lt; Multiplier ? &#123;Multiplicand ，Multiplier&#125; : &#123;Multiplier ，Multiplicand&#125;； 于是,改进版传统乘法器实现的大致操作如下： 在初始化之际，取乘数和被乘数的正负关系，然后取被乘数和乘数的正值。 乘数和被乘数比较，如果被乘数小于乘数，结果乘数和被乘数互换。 每一次累加操作，递减一次乘数。直到乘数的值为零，表示操作结束。 输出结果根据正负关系取得。 传统的乘法器无论如何改进也好，当遇见如 127 x 127 的乘数和被乘数，咋样也看不出什么可以优化的地方… 1.4 补码的意义上面也说到过一点，就是实现正数和负数之间的转换，也就是说使符号位能与有效值部分一起参加运算,从而简化运算规则。 另外，还有一点就是使减法运算转换为加法运算,进一步简化计算机中运算器的线路设计。 1.5 Booth算法乘法器 未完待续。。。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>FPGA</tag>
        <tag>笔记</tag>
        <tag>乘法器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《9号秘事》]]></title>
    <url>%2F2018%2F02%2F11%2F%E5%BD%B1%E8%AF%84%2F%E3%80%8A9%E5%8F%B7%E7%A7%98%E4%BA%8B%E3%80%8B%2F</url>
    <content type="text"><![CDATA[前言昨天花了一晚上时间把神剧《9号秘事》的第2、3、4季都刷完了。当看完最后一集时慢慢合上电脑，深深地吸了口气，可以说是非常的爽了。说实话，上一次有这种感觉的时候还是看完《黑镜》那会了。 躺床上后，我迟迟不能入睡，脑子里还处理着剧里的信息。经历各种思考后，我决定把我觉得重要的东西写下来，一来整理下自己的思路，写下自己的观后感，二来当作笔记，生怕时间久后忘了精彩的情节。 第一季[还没看] 第二季首播时间：2015-03-26(英国) 豆瓣评分：8.8（截至编辑时间） IMDb评分：8.2（截至编辑时间） 第1集 故事概况： 秘事发生在一节9号列车卧铺车厢里。医生Maxwell为了得到工作，杀死了恰巧在同一车厢的竞争对手Meyer，但在下车前才发现自己杀错人了，真正的Meyer医生睡错了床，而且在此之前他还得到了Maxwell的帮助。 说实话，第一眼看到男主，我一度以为是《纸牌屋》里的弗兰克，虽然我知道不可能，但实在是太像了，眼神，动作，神态。。。像极了年轻版的弗兰克！另外，英国人的口音实在是让人无法抗拒啊啊啊！！！ 咳咳，回到剧情。 一开始车厢里只有Maxwell医生和一个已经睡着了的人（说实话不是很懂为啥要叫Maxwell这个名字。。。），在Maxwell躺下准备睡觉后，来了一位彪形大汉，虽西装革履，但体态只能说类似流浪汉，吵吵闹闹，莽莽撞撞，而且似乎哪里不舒服，一直咳嗽。Maxwell忍受不了争吵几句过后便各自睡觉去了。不就，来了一对老夫妻，是去参加女儿婚礼的，显然，又是吵吵闹闹。最后进来的是个fat gril，是个旅行家，一直在打电话，一会又出去了。 到这里，显然这节车厢里的人物都亮相了。说实话，我对接下来的剧情发展毫无头绪。前期导演拍了很多看似无关紧要、乱七八糟的情节（对于细节的把控很是到位，看似纷乱复杂，实则耐人寻味，幽默风趣），但这些情节对人物形象的塑造很是关键，为后面的情节做了很好的铺垫，可以说，缺一不可。【在这里忍不住想夸一下演员的演技了，可以说这部剧里的演员没一个是我觉得帅或者漂亮的，可人家硬是靠演技把人物演活了。反观国内，哎。。。或许某天，等国民消费水平提高了，我们不再买单无脑的肥皂剧了，不再期待闭着眼都能猜到的剧情了，知道自己想要的是什么了，愿意花钱买优质服务了之后，才会有类似HBO、英国电视4台、NetFlix等公司的优秀作品吧。。。】 情节的反转是在旅行女打完电话后回来开始的，同时，她又带回了个炮友。闲聊了会后，他俩就开始躺床上了（虽然说很多国外高分剧都充斥着暴力、色情等元素，但我至少没有在英剧里见过。额，美剧里倒是不少，特别是HBO的。。。），就在这时，那男的看到上铺的乘客的头悬在床边，惊醒了一车的人。 说到底就是突然发现自己的车厢中有具尸体，乘客都有啥反应。（额，那我上面为什么要说那么多。。。）其实有趣就有趣在这里，每个人物做出的的反应是如此真实，合情合理，但总感觉略有违和感。先来说医生Maxwell，他首先站出来说都别动，我是医生，在确认那人死后又出去找警卫，让其他人都别走。到这里，都没什么特别的，作为一个医生，这些都是常规操作。其次，说说那个胖叔叔，真正的Meyer医生，他下床后第一件事就是翻死者的口袋，找到了个钱包，里面有张家庭合照。显然，他已经当爷爷了，众人都感到惋惜。这时Maxwell医生回来了，说找不到人。没办法，这时候只能用紧急停止按钮了。 。。。。。。桂桂，怎么写了辣么多了，这才第一集啊，后面怎么办哟。。。算了，后面不写那么详细了，难得写影评没想说的太多没收住。。。先这样吧，下次有空再更——2018/2/11 第2集第3集第4集第5集第6集]]></content>
      <categories>
        <category>影评</category>
      </categories>
      <tags>
        <tag>英剧</tag>
        <tag>烧脑神剧</tag>
        <tag>9号秘事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matlab产生测试激励]]></title>
    <url>%2F2018%2F02%2F11%2FMatlab%2FMatlab%E4%BA%A7%E7%94%9F%E6%B5%8B%E8%AF%95%E6%BF%80%E5%8A%B1%2F</url>
    <content type="text"><![CDATA[前言在FPGA开发过程中几乎都要用到仿真的功能，对于一些简单的外部激励（如时钟、复位、简单数据或者信号等）直接在testbench中编写产生就行了，但对于复杂的外部激励数据，很难在testbench中产生，这时就要通过读取外部文件里的数据来实现。通过和matlab的配合使用，基本上可以模拟各种外部激励。举例来说：输入信号是三个不同频率的正弦波的相加，经过FIR低通滤波器滤除高频分量，输出频率最低的那个正弦信号。这种情况下测试用的输入信号不能通过testbench编写产生。简单来说有以下两种方法可以模拟输入信号： 在FPGA内部通过DDS产生三个正弦波，然后将三个波形相加作为输入信号。 利用matlab产生输入信号，将数据导出为.txt文件，在仿真时读取文件内的数据作为外部激励。 显然第二种方法更加灵活和便捷。下面，具体介绍一下这种方法的使用。 平台： Vivado 16.4 Matlab R2017b Matlab程序编写： 代码如下： 1234567891011121314151617181920212223242526272829303132333435%=============设置系统参数==============%f1=1e6; %设置波形频率f2=500e3;f3=800e3;Fs=20e6; %设置采样频率L=1024; %数据长度N=14; %数据位宽%=============产生输入信号==============%t=0:1/Fs:(1/Fs)*(L-1);y1=sin(2*pi*f1*t);y2=sin(2*pi*f2*t);y3=sin(2*pi*f3*t);y4=y1+y2+y3;y_n=round(y4*(2^(N-3)-1)); %N比特量化;如果有n个信号相加，则设置（N-n）%=================画图==================%a=10; %改变系数可以调整显示周期stem(t,y_n);axis([0 L/Fs/a -2^N 2^N]); %显示%=============写入外部文件==============%fid=fopen(&apos;E:\Workspace\Vivado_16.4\TEST\TestBench\sin_data.txt&apos;,&apos;w&apos;); %把数据写入sin_data.txt文件中，如果没有就创建该文件for k=1:length(y_n) B_s=dec2bin(y_n(k)+((y_n(k))&lt;0)*2^N,N); for j=1:N if B_s(j)==&apos;1&apos; tb=1; else tb=0; end fprintf(fid,&apos;%d&apos;,tb); end fprintf(fid,&apos;\r\n&apos;);endfprintf(fid,&apos;;&apos;);fclose(fid); 此程序中设置了三个频率分别为1M、500k和800k的正弦波，然后将三个波形相加并且量化后作为输出。最后将路径设置为相应文件所在路径即可，需要注意的是如果对应路径下没有相应文件，则会自动新建文件并写入数据。 运行程序： 打开对应的文件目录可以看到二进制数据文件已经生成。 接下来就可以进行在testbench中读取外部数据的操作了。 Testbench的编写： 代码如下： 12345678910111213141516171819202122232425`timescale 1ns/1psmodule TB_readfile();reg SCLK;reg [13:0] data_out;//--------------时钟部分----------------//initial SCLK = 0;always #10 SCLK = ~SCLK;//-------------------------------------//parameter data_num = 32&apos;d1024;integer i = 0;reg [13:0] data_men[1:data_num];reg [13:0] data_reg = 0;initial begin $readmemb(&quot;E:/Workspace/Vivado_16.4/2017_8_28_TEST/TestBench/sin_data.txt&quot;,data_men); //注意斜杠的方向，不能反&lt;&lt;&lt;&lt;&lt;&lt;&lt;endalways @(posedge SCLK) begin data_out &lt;= data_men[i]; i &lt;= i + 8&apos;d1;end//------------------------------------//endmodule 因为这里只需要读取外部数据，所以Vivado工程里只需要添加仿真文件就行了。 运行仿真：可以看到，仿真的波形和matlab中显示的波形一致，说明结果正确。 结束语Matlab可以说是个很强大的工具，在设计中合理的使用matlab可以起到事半功倍的效果。当然我也在不断的学习中，如果有疑问或者更好的想法欢迎交流。。。]]></content>
      <categories>
        <category>Matlab</category>
      </categories>
      <tags>
        <tag>Matlab</tag>
        <tag>Testbench</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AM解调的FPGA实现]]></title>
    <url>%2F2018%2F02%2F09%2FFPGA%2FAM%E8%A7%A3%E8%B0%83%E7%9A%84FPGA%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[一、说明： 功能：AM解调 平台：Vivado 2016.4 和 Matlab R2017a 二、原理：1.AM解调原理 模拟电路中采用“包络检波”的方法： 数字电路中采用类似的方法：先将已调信号取绝对值，再经过低通滤波器，滤除高频分量（经AM调制的信号包含两个高频分量：载波频率+/-调制信号频率，因此低通滤波器的截止频率小于两个高频分量就可以），得到的就是叠加了直流分量的调制信号，去直流后便可以得到调制信号。 三、AM解调的FPGA实现1.将已调制的AM信号取绝对值关于AM信号的产生，参见上一篇博客：AM调制的FPGA实现 简单说明一下对数据取反的思路：如果是无符号数，则不存在符号位，也就是说数据都是正数，不需要取绝对值；如果是有符号数，通过检测最高位的符号位，如果符号位是1，则表示数据是负数，对数据取反，如果符号位是0，则表示数据是正数，不需要取反操作。 取绝对值的Verilog实现： 1234567891011121314always @(posedge clk or negedge rst_n) begin if(!rst_n) begin data_tdata &lt;= 0; end else if(AM_mod[15] == 1) begin data_tdata &lt;= -&#123;AM_mod&#125;; //如果符号位是1，对数据取反 end else if(AM_mod[15] == 0) begin data_tdata &lt;= AM_mod; //如果符号位是0，数据不变 end else begin data_tdata &lt;= data_tdata; endend 2.使用FIR滤波器滤除高频分量关于Vivado的FIR IP核可以说是功能很强大的，但这里不需要其他复杂的功能，只需要简单的生成一个的低通滤波器就行了。类似于ROM核的生成，配置FIR同样需要Matlab配合。可见，Matlab的功能是多么强大。这里Matlab的主要作用是对滤波器的性能进行仿真并生成相应的抽头系数。 使用Matlab生成FIR的抽头系数 在Matlab的命令行窗口输入：filterDesigner（以前是用fdatool命令，不过输入fdatool也可以，只是会提醒你改用新的命令）弹出滤波器设计窗口： 接下来，对滤波器的一些参数进行设置： 参数设置好后，点击Design Filter 按钮查看生成滤波器的幅频响应图，通过幅频响应等图来判断滤波器是否达到设计要求： 设计的滤波器满足性能指标后需要将抽头系数导出，保存为.coe文件。在导出前需要对系数进行量化。因为需要解调的AM信号也是16位宽，所以这里的位宽设置保持默认值，这些可以根据实际情况自行修改。 量化过后就能将抽头系数导出为.coe文件了： 生成FIR IP核 IP核的具体配置如下： 其他保持默认即可： 同样，在IP核配置界面也可以查看滤波器的幅频特性： IP核生成完毕后，就可以编写IP核的调用模块了。 FIR IP核调用模块： 123456789101112131415161718192021222324252627282930313233module FIR_Control( input clk, input rst_n, input signed [15:0] s_axis_data_tdata, output reg [7:0] data_out);wire s_axis_data_tready;wire m_axis_data_tvalid;wire [39:0] m_axis_data_tdata; //滤波器输出信号always @(posedge clk or negedge rst_n) begin if(!rst_n) begin data_out &lt;= 0; end else begin data_out &lt;= m_axis_data_tdata[33:26]; //根据仿真结果进行截位 endend//--------------调用FIR核----------------//FIR FIR_inst0( .aclk (clk), .s_axis_data_tvalid (1), //拉高时IP核开始工作 .s_axis_data_tready (s_axis_data_tready), .s_axis_data_tdata (s_axis_data_tdata), //输入信号 .m_axis_data_tvalid (m_axis_data_tvalid), //拉高时表明数据输出有效 .m_axis_data_tdata (m_axis_data_tdata) //输出信号);//---------------------------------------//endmodule 需要注意的是：m_axis_data_tdata 信号是滤波器的数据输出信号，我们在使用时一般都要对此数据进行截位操作，如何进行截位需要根据仿真结果来确定。比如，在这个工程中，我需要的滤波器的输出数据是8位，但不能一下子截取高8位，而且m_axis_data_tdata是个40位的数据，从仿真波形来看m_axis_data_tdata[39:34]都是符号位，因此从33位开始往下截取8位数据（当然也可以从34位开始截，这样的话就多了一位符号位，相应的数据位就变少了一位）。 3.去直流处理经过FIR滤波后的波形其实就是一个叠加了直流分量的调制信号。在本工程中，AM调制是100%调制，也就是说解调时经过FIR后的信号的最小值为0，可以把它看作是无符号的数，直接经DA输出就行了。如果不是100%调制呢？也就是说解调时经过FIR后的信号的最小值是大于0的，那么这个大于0的量就相当于直流，需要去掉后再经DA输出。因此，在这个工程中，不需要去直流处理。下面给出顶层文件的代码。 顶层模块编写： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546module TOP( input clk, input rst_n, output [7:0] AM_demod);//--------------------------------//reg signed [15:0] data_tdata;wire signed [15:0] AM_mod;//--------------------------------////-----------取绝对值-------------//always @(posedge clk or negedge rst_n) begin if(!rst_n) begin data_tdata &lt;= 0; end else if(AM_mod[15] == 1) begin data_tdata &lt;= -&#123;AM_mod&#125;; //如果符号位是1，对数据取反 end else if(AM_mod[15] == 0) begin data_tdata &lt;= AM_mod; //如果符号位是0，数据不变 end else begin data_tdata &lt;= data_tdata; endend//--------------------------------////-----------AM已调信号------------//modulate modulate_inst0( .clk (clk), .rst_n (rst_n), .AM_mod (AM_mod));//--------------------------------////----------滤波器控制模块---------//FIR_Control FIR_Control_inst2( .clk (clk), .rst_n (rst_n), .s_axis_data_tdata (data_tdata), .data_out (AM_demod));//--------------------------------//endmodule 4.解调仿真 编写TestBeach： 123456789101112131415161718192021222324252627`timescale 1ns/1psmodule tb_AM();//===================解调部分====================////----------接口设置----------//reg sclk;reg rst_n;wire [7:0] AM_demod;//--------------------------//initial sclk = 1;always #5 sclk = ~sclk; //100M时钟initial begin rst_n = 0; #500 rst_n = 1;end//----------解调模块----------//TOP TOP_inst( .clk (sclk), .rst_n (rst_n), .AM_demod (AM_demod));//---------------------------//endmodule 仿真结果 由仿真结果可知，最终输出信号正确还原了已调制信号的包络，表明解调正确。]]></content>
      <categories>
        <category>FPGA</category>
      </categories>
      <tags>
        <tag>FPGA</tag>
        <tag>AM</tag>
        <tag>调制解调</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AM调制的FPGA实现]]></title>
    <url>%2F2018%2F02%2F09%2FFPGA%2FAM%E8%B0%83%E5%88%B6%E7%9A%84FPGA%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[一、说明： 功能：AM调制 平台：Vivado 2016.4 和 Matlab R2017a 二、原理：1. AM调制原理 AM已调信号的时域表达式： 已调信号的频域表达式：本质上AM调制就是频谱的搬移。 AM调制的系统框图将调制信号加上一个直流分量，保证信号的最小值大于零，然后再和载波相乘，得到已调信号。 三、AM调制的FPGA实现1.产生调制信号和载波信号调用ROM IP核在FPGA内部产生两路余弦信号，其中一路信号用于模拟外部输入的调制信号，另一路用作载波信号。在配置ROM IP核之前，需要用Matlab生.coe文件，存放在ROM核里。 Matlab生成.coe文件： 123456789101112131415161718192021222324%---------------------------------%width=8; %设置rom的位宽depth=1024; %设置rom的深度%---------------------------------%x=linspace(0,2*pi,depth); %在一个周期内产生depth个采样点y_cos=cos(x); %生成余弦函数%y_cos=sin(x); %生成正弦函数%y_cos=round(y_cos*(2^(width-1)-1))+2^(width-1)-1; %将数据转化成整数,生成无符号数y_cos=round(y_cos*(2^(width-1)-1)); %将数据转化成整数,生成有符号数plot(x,y_cos); %绘图fid = fopen(&apos;E:\Workspace\DDS\Design\IP_Core\cos.coe&apos;,&apos;wt&apos;);fprintf(fid,&apos;memory_initialization_radix = 10;\nmemory_initialization_vector = &apos;);for i = 1 : depth if mod(i-1,8) == 0 fprintf(fid,&apos;\n&apos;); end fprintf(fid,&apos;%6d,&apos;,y_cos(i));endfclose(fid); %关闭文件 生成.coe文件后就可以进行IP核的配置了。 ROM核具体配置： 配置完IP核后，编写控制模块，产生两路信号。其中，调制信号上叠加的直流分量的大小为调制信号的峰值，这样将得到调制度为100%的已调信号。如果要得到不同的调制度，则需要叠加不同大小的直流分量，同时需要注意定义的数据位宽，防止数据溢出。 产生载波和带有直流分量的调制信号： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758module cos_make( input clk, input rst_n, output reg [7:0] cos_s, output reg signed [7:0] cos_c);//------------------------------------//parameter freq_s = 32&apos;d429497; //调制信号频率10kparameter freq_c = 32&apos;d42949673; //载波频率1Mparameter cnt_width = 8&apos;d32;//------------------------------------////------------------------------------//reg [cnt_width-1:0] cnt_s = 0;reg [cnt_width-1:0] cnt_c = 0;wire [9:0] addr_s;wire [9:0] addr_c;always @(posedge clk or negedge rst_n) begin if(!rst_n) begin cnt_s &lt;= 0; cnt_c &lt;= 0; end else begin cnt_s &lt;= cnt_s + freq_s; cnt_c &lt;= cnt_c + freq_c; endendassign addr_s = cnt_s[cnt_width-1:cnt_width-10];assign addr_c = cnt_c[cnt_width-1:cnt_width-10];//------------------------------------////------------调用ROM核----------------//wire signed [7:0] cos_s_r;wire signed [7:0] cos_c_r;ROM ROM_inst( .clka (clk), .addra (addr_s), .douta (cos_s_r), .clkb (clk), .addrb (addr_c), .doutb (cos_c_r));always @(posedge clk or negedge rst_n) begin if(!rst_n) begin cos_s &lt;= 0; cos_c &lt;= 0; end else begin cos_s &lt;= cos_s_r + 8 &apos;d128; //加上大小为峰值的直流分量 cos_c &lt;= cos_c_r; endendendmodule 2.生成AM调制信号得到两路信号后就可以用乘法器将两路信号相乘，得到已调信号。 乘法器具体配置： AM调制的顶层模块： 123456789101112131415161718192021222324252627module modulate( input clk, input rst_n, output signed [15:0] AM_mod);wire [7:0] cos_s;wire signed [7:0] cos_c;//------------调用出波模块------------//cos_make cos_make_inst0( .clk (clk), .rst_n (rst_n), .cos_s (cos_s), .cos_c (cos_c));//-----------------------------------////------------调用乘法器--------------//MULT MULT_inst1( .CLK (clk), .A (cos_s), .B (cos_c), .P (AM_mod));endmodule 3.仿真调制结果以上AM调制过程基本完成，但是正确与否还需要通过仿真来确定，接下来编写仿真用的测试模块。 TestBeach的编写： 12345678910111213141516171819202122232425`timescale 1ns/1psmodule tb_AM();//---------接口设置----------//reg sclk;reg rst_n;wire signed [15:0] AM_mod;//--------------------------//initial sclk = 1;always #5 sclk = ~sclk; //100M时钟initial begin rst_n = 0; #500 rst_n = 1;end//--------------------------//modulate modulate_inst0( .clk (sclk), .rst_n (rst_n), .AM_mod (AM_mod));endmodule 在Vivado中将各个文件添加进工程后，运行仿真。 仿真结果如下： 已调信号能明显看到包络，并且包络的频率同调制信号一致，表明AM调制正确。]]></content>
      <categories>
        <category>FPGA</category>
      </categories>
      <tags>
        <tag>FPGA</tag>
        <tag>AM</tag>
        <tag>调制解调</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于博客]]></title>
    <url>%2F2018%2F02%2F06%2F%E4%B8%AA%E4%BA%BA%2F%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[我的博客之路 种一棵树最好的时间是什么时候？ 十年之前。 简单来说，我的博客之路主要分为以下几个阶段： 第一阶段：从刚接触博客到真正开始写博客经历了很长时间。我的第一篇博客是在博客园写的，在决定写博客之前收集了很多信息，包括在知乎，Google等上查如何写博客？为什么要写博客？在哪里写博客？之类的问题。犹豫了很久，才决定在博客园上写。 第二阶段：在博客园上写了两篇不怎么样的博客后就很长一段时间都没在写博客，一方面是学业较忙，另一方面是确实没什么产出，因为一开始给自己博客的定位是技术类博客，所以不是干货也不愿意放博客上。后来一次偶然的机会，发现周围很多人都在CSDN，而那段时间正好用上了MarkDown，所以决定尝试用CSDN的MarkDown编辑器写博客，然后发现界面居然还挺好看的，体验真心不错，至少比博客园的编辑体验好多了（说实话，编辑体验确实很能影响写博客的心情），于是乎决定在CSDN常驻下来，曾一度以为这里是我的博客归属地了。 第三阶段：随着时间的推移，慢慢的开始胡思乱想了，万一博客园和CSDN倒闭了怎么办，之前的文章不就都没了吗;把自己的心得、成果都放在别人家的网站上总感觉不太放心，总感觉不是属于自己的东西（原谅我奇怪的占有欲233）。于是萌生了利用GitHub搭建博客的想法，但又突然想到万一GitHub倒闭了或者被墙了怎么办？毕竟GitHub被墙比CSDN倒闭的可能性大多了。。。于是一个偶然的机会看到了开头的那句话。可以说，这句话是我开始动手建站的导火索。是啊，纠结是最弱智的行为。在经历了两个晚上的折腾之后终于搭建完了自己的博客。可以说是满满的成就感啊！ 目前我的写博客流程基本是这样的： 在本地用MarkDown写完博客后推到个人博客，作为博客的出处。 将本地博客导入到CSDN进行发布。 将本地文件内容复制到博客园进行发布。 当然，平台什么的都是其次，主要是有产出，而这个博客站点的搭建也是为了激励我坚持写博客。 但行好事，莫问前程！]]></content>
      <categories>
        <category>个人</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github搭建博客教程]]></title>
    <url>%2F2018%2F02%2F05%2FHEXO%2FGithub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[一、前言：关于本博客的搭建，参考了很多网上的教程，虽然说网上教程很多，但总觉得很分散，每个教程的着重点都不一样，因此我顺便整理了下在自己搭建博客过程中参考过的教程。 二、搭建步骤：2.1 软件安装：不详细讲，具体教程网上很多，nodejs和git的安装基本都默认下一步。 2.2 搭建本地博客 安装hexo 打开cmd命令（WIN+R），执行命令 npm install hexo-cli -g 等待自动安装完成后，输入 hexo -v 可以检查是否安装成功，如果没问题可以继续。 初始化hexo 新建一个文件夹Hexo，用于存放博客，配置等。右键 Git Bash Here 直接定位到当前文件夹,然后执行 hexo init 初始化配置文件,可能时间比较长，耐心等待。完成后，输入 npm install 配置node。接下来输入 hexo g 加载hexo基础html、css、js等文件。在这完成后等于已经在本地创建了一个网页，想查看的话，输入 hexo s 这相当于开启了一个本地的服务器，会提示你拷贝url到浏览器。（Ctrl + C 是停止的意思，不是复制！） 这里注意：不要Ctrl+C！不要Ctrl+C！不要Ctrl+C！ 把网址输入到浏览器就能访问本地网页了。 一定要先浏览网页再执行Ctrl+C结束，顺序颠倒会导致访问不了网页。 但如果提示错误解决办法如下：Hexo server not working；Hexo 无法访问页面 打开文件Hexo/_config.yml,添加如下代码 123456server: port: 5000 # or anohter number log: false ip: 0.0.0.0 compress: false header: true 如图所示 重新输入 hexo s 端口号会变成5000。同样，先输入网址。 至此，本地博客框架搭建完成 DIY博客主题 之前的博客界面主题是默认的，当然是要换成别的啦。说是DIY，其实就是搬运别人的主题。下面按照我的主题举例介绍如何搬运。 首先输入 git clone https://github.com/yelog/hexo-theme-3-hexo.git themes/3-hexo 把对应的主题clone到本地Hexo/theme/3-hexo下 这时在theme文件夹下面多了一个3-hexo的文件夹，这就是下载下来的主题。 修改根目录下的 _config.yml文件 theme: 3-hexo 再次运行 hexo s 到这里为止，主题算是搬运完了，接下来就是细节上的修改，将别人的主页变成自己的，具体修改方法参考原作者在GitHub上的说明。 2.3 部署到GitHub 配置远程仓库地址 在根目录下的 _config.yml文件中修改 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/用户名/用户名.github.io.git branch: master 其他 具体可以参考其他参考教程。 关于新建分支用于存放源文件的操作其他参考教程上也有。 三、使用方法：3.1 编写博客 打开git： 右键 Git Bash Here，定位到当前文件夹 新建文章： hexo new “文件名字” 3.2 部署博客 本地写完后，将本地源文件备份到github： 123git add .git commit -m &quot;备注&quot;git push origin hexo 将文件转换为网页，部署到博客： hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 四、参考网站：next主题配合简书 也可以看Hexo置顶及排序问题等主要参考如何设置主题 主要看使用hexo+github免费搭建个人博客网站超详细教程另外GitHub Pages + Hexo搭建博客\以及Hexo+Github搭建个人博客两个分支方便维护等主要参考如何部署和维护 其他有关修改主题内容的教程：为 hexo NexT 添加 Gitment 评论插件和Hexo Next 主题博客添加gitment评论功能]]></content>
      <categories>
        <category>HEXO</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>搭建博客</tag>
      </tags>
  </entry>
</search>
