<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>DOOKNET.Blog</title>
    <link>https://DOOKNET.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>但行好事，莫问前程</description>
    <pubDate>Thu, 01 Mar 2018 08:46:02 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>关于乘法器的那些事</title>
      <link>https://DOOKNET.github.io/2018/02/26/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%85%B3%E4%BA%8E%E4%B9%98%E6%B3%95%E5%99%A8%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</link>
      <guid>https://DOOKNET.github.io/2018/02/26/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%85%B3%E4%BA%8E%E4%B9%98%E6%B3%95%E5%99%A8%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</guid>
      <pubDate>Mon, 26 Feb 2018 13:07:36 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;一、整数乘法器&quot;&gt;&lt;a href=&quot;#一、整数乘法器&quot; class=&quot;headerlink&quot; title=&quot;一、整数乘法器&quot;&gt;&lt;/a&gt;一、整数乘法器&lt;/h1&gt;&lt;h2 id=&quot;1-1-整数的概念&quot;&gt;&lt;a href=&quot;#1-1-整数的概念&quot; class=&quot;header
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="一、整数乘法器"><a href="#一、整数乘法器" class="headerlink" title="一、整数乘法器"></a>一、整数乘法器</h1><h2 id="1-1-整数的概念"><a href="#1-1-整数的概念" class="headerlink" title="1.1 整数的概念"></a>1.1 整数的概念</h2><p>整数在<a href="https://zh.wikipedia.org/wiki/%E7%94%B5%E6%B0%94%E7%94%B5%E5%AD%90%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AD%A6%E4%BC%9A" target="_blank" rel="noopener">IEEE</a>的规定上有，短整数 short integer ，中整数 integer 和 长整数 long integer ，他们之间的关系如下：<br>|整数   |字节空间|取值范围|<br>| :—: | :—: | :—: |<br>|短整数 |一个字节|-127 ~ 127|<br>|整数   |二个字节|-32767~32767|<br>|长整数 |四个字节|-2147483647~2147483647|<br>若无特殊说明，以下都以短整数举例。</p><p><strong>四个结论：</strong></p><ul><li>短整数的最高位是符号位，正值的符号位是“0”，负值的符号位是“1”。</li><li>正值用原码表示，负值用补码表示。</li><li>正值(8’b0000_0100)“取反加一”就得到负值(8’b1111_1100) ； 同理，负值(8’b1111_1100)“取反加一”就得到正值(b’b0000_0100)。</li><li>8’b1000_0000既不是正数也不是负数也不是0，它是划分正值和负值的边界线。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+4   即 8&apos;b0000_0100;</span><br><span class="line">+127 即 8&apos;b0111_1111;</span><br><span class="line">分界线  8&apos;b1000_0000;</span><br><span class="line">-127 即 8&apos;b1000_0001;</span><br><span class="line">-4   即 8&apos;b1111_1100;</span><br></pre></td></tr></table></figure><h2 id="1-2-传统乘法器"><a href="#1-2-传统乘法器" class="headerlink" title="1.2 传统乘法器"></a>1.2 传统乘法器</h2><p>在传统概念上，乘法等价于“重复几次”，也就是累加操作。比如：B=4,那么A x B等价于A重复加四次。那如果B=-4应该怎么理解呢？<br>先来看一组例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A x B = C；</span><br><span class="line">3 x 4 = 12;</span><br><span class="line">-3x 4 = -12;</span><br><span class="line">3 x-4 = -12;</span><br><span class="line">-3x-4 = 12;</span><br></pre></td></tr></table></figure></p><p>其中，C的值可以看成由两部分构成：正负和数值。</p><p>撇开正负不看，乘积的数值就是A和B绝对值相乘的结果。那么乘积的正负如何确定呢？</p><p>其实正负号的运算规则和数字电路中的“异或运算”一样。<br>   A  |B    |C(A⊕B)<br> :—:|:—:|:—:<br>   0  |  0  |    0<br>   0  |     1  |    1<br>   1  |  0  |    1<br>   1  |  1  |    0<br>其中，0表示正号，1表示负号。</p><p>因此，传统乘法器实现的大致操作如下：</p><ol><li>在初始化之际，取乘数和被乘数的正负关系,然后取乘数和被乘数的正值。</li><li>每一次累加操作，递减一次乘数。直到乘数的值为零，表示操作结束。</li><li>输出结果根据正负关系取得。</li></ol><p>其实传统的乘法器是很容易的，但是随着整数的出现，负值和正值也随着出现，这也使得设计多了一点难度。但是只要掌握负值和正值的关系以后，乘法只作正值也“无问题” ，只要在结果输出之前“下一点手脚”就行了。</p><h2 id="1-3-传统乘法器的改进"><a href="#1-3-传统乘法器的改进" class="headerlink" title="1.3 传统乘法器的改进"></a>1.3 传统乘法器的改进</h2><p>传统的乘法器虽然简单，但是它有一个致命的问题。就是被乘数越大就越消耗时钟。那么要解决这个问题就要了解为什么会产生这个问题。还是举例来说：</p><p>假设A=10 , B=20 , A x B ，那么时钟的消耗至少需要 20个，因为A值需要累加20次才能得到结果。回顾一下乘法法则：A x B = B x A。如果以B作为基础，那么B值只需要累加10次就能得到结果，这样就可以节省时钟的消耗。</p><p>因此我们可以这样改进：在进行累加操作之前，增加一个比较步骤。如果被乘数小于乘数，那么被乘数和乘数互换。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;Multiplier , Multiplicand&#125; = Multiplicand &lt; Multiplier ? &#123;Multiplicand ，Multiplier&#125; : &#123;Multiplier ，Multiplicand&#125;；</span><br></pre></td></tr></table></figure></p><p>于是,改进版传统乘法器实现的大致操作如下：</p><ol><li>在初始化之际，取乘数和被乘数的正负关系，然后取被乘数和乘数的正值。</li><li>乘数和被乘数比较，如果被乘数小于乘数，结果乘数和被乘数互换。</li><li>每一次累加操作，递减一次乘数。直到乘数的值为零，表示操作结束。</li><li>输出结果根据正负关系取得。</li></ol><p>传统的乘法器无论如何改进也好，当遇见如 127 x 127 的乘数和被乘数，咋样也看不出什么可以优化的地方…</p><h2 id="1-4-补码的意义"><a href="#1-4-补码的意义" class="headerlink" title="1.4 补码的意义"></a>1.4 补码的意义</h2><p>上面也说到过一点，就是实现正数和负数之间的转换，也就是说使符号位能与有效值部分一起参加运算,从而简化运算规则。</p><p>另外，还有一点就是使减法运算转换为加法运算,进一步简化计算机中运算器的线路设计。</p><h2 id="1-5-Booth算法乘法器"><a href="#1-5-Booth算法乘法器" class="headerlink" title="1.5 Booth算法乘法器"></a>1.5 Booth算法乘法器</h2><hr><h1 id="未完待续。。。"><a href="#未完待续。。。" class="headerlink" title="未完待续。。。"></a>未完待续。。。</h1>]]></content:encoded>
      
      <comments>https://DOOKNET.github.io/2018/02/26/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%85%B3%E4%BA%8E%E4%B9%98%E6%B3%95%E5%99%A8%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/#disqus_thread</comments>
    </item>
    
    <item>
      <title>《9号秘事》</title>
      <link>https://DOOKNET.github.io/2018/02/11/%E5%BD%B1%E8%AF%84/%E3%80%8A9%E5%8F%B7%E7%A7%98%E4%BA%8B%E3%80%8B/</link>
      <guid>https://DOOKNET.github.io/2018/02/11/%E5%BD%B1%E8%AF%84/%E3%80%8A9%E5%8F%B7%E7%A7%98%E4%BA%8B%E3%80%8B/</guid>
      <pubDate>Sun, 11 Feb 2018 07:43:12 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;昨天花了一晚上时间把神剧《9号秘事》的第2、3、4季都刷完了。当看完最后一集时慢慢合上电脑，深深地吸了口气，可以说是非常的爽了。说实话，上一
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>昨天花了一晚上时间把神剧《9号秘事》的第2、3、4季都刷完了。当看完最后一集时慢慢合上电脑，深深地吸了口气，可以说是非常的爽了。说实话，上一次有这种感觉的时候还是看完《黑镜》那会了。</p><p>躺床上后，我迟迟不能入睡，脑子里还处理着剧里的信息。经历各种思考后，我决定把我觉得重要的东西写下来，一来整理下自己的思路，写下自己的观后感，二来当作笔记，生怕时间久后忘了精彩的情节。</p><hr><h1 id="第一季"><a href="#第一季" class="headerlink" title="第一季"></a>第一季</h1><p>[还没看]</p><hr><h1 id="第二季"><a href="#第二季" class="headerlink" title="第二季"></a>第二季</h1><p>首播时间：2015-03-26(英国)</p><p><a href="https://movie.douban.com/subject/26341777/" target="_blank" rel="noopener">豆瓣</a>评分：8.8（截至编辑时间）</p><p><a href="http://www.imdb.com/title/tt4513394/" target="_blank" rel="noopener">IMDb</a>评分：8.2（截至编辑时间）</p><h2 id="第1集"><a href="#第1集" class="headerlink" title="第1集"></a>第1集</h2><p><img src="https://user-images.githubusercontent.com/29295862/36075132-1ab83574-0f85-11e8-9f29-9c54020d4615.png" alt="9号秘事"></p><p><img src="https://user-images.githubusercontent.com/29295862/36075135-201825ce-0f85-11e8-96c0-484ef73fca36.png" alt="9号列车卧铺车厢"></p><ul><li><p><strong>故事概况：</strong></p><p> 秘事发生在一节9号列车卧铺车厢里。医生Maxwell为了得到工作，杀死了恰巧在同一车厢的竞争对手Meyer，但在下车前才发现自己杀错人了，真正的Meyer医生睡错了床，而且在此之前他还得到了Maxwell的帮助。</p></li></ul><p>说实话，第一眼看到男主，我一度以为是《纸牌屋》里的弗兰克，虽然我知道不可能，但实在是太像了，眼神，动作，神态。。。像极了年轻版的弗兰克！另外，英国人的口音实在是让人无法抗拒啊啊啊！！！</p><p><img src="https://user-images.githubusercontent.com/29295862/36075144-4327ce3e-0f85-11e8-9544-128fa5765e97.png" alt="Dr Maxwell"></p><p>咳咳，回到剧情。</p><p>一开始车厢里只有Maxwell医生和一个已经睡着了的人（说实话不是很懂为啥要叫Maxwell这个名字。。。），在Maxwell躺下准备睡觉后，来了一位彪形大汉，虽西装革履，但体态只能说类似流浪汉，吵吵闹闹，莽莽撞撞，而且似乎哪里不舒服，一直咳嗽。Maxwell忍受不了争吵几句过后便各自睡觉去了。不就，来了一对老夫妻，是去参加女儿婚礼的，显然，又是吵吵闹闹。最后进来的是个fat gril，是个旅行家，一直在打电话，一会又出去了。</p><p>到这里，显然这节车厢里的人物都亮相了。说实话，我对接下来的剧情发展毫无头绪。前期导演拍了很多看似无关紧要、乱七八糟的情节（对于细节的把控很是到位，看似纷乱复杂，实则耐人寻味，幽默风趣），但这些情节对人物形象的塑造很是关键，为后面的情节做了很好的铺垫，可以说，缺一不可。【在这里忍不住想夸一下演员的演技了，可以说这部剧里的演员没一个是我觉得帅或者漂亮的，可人家硬是靠演技把人物演活了。反观国内，哎。。。或许某天，等国民消费水平提高了，我们不再买单无脑的肥皂剧了，不再期待闭着眼都能猜到的剧情了，知道自己想要的是什么了，愿意花钱买优质服务了之后，才会有类似HBO、英国电视4台、NetFlix等公司的优秀作品吧。。。】</p><p>情节的反转是在旅行女打完电话后回来开始的，同时，她又带回了个炮友。闲聊了会后，他俩就开始躺床上了（虽然说很多国外高分剧都充斥着暴力、色情等元素，但我至少没有在英剧里见过。额，美剧里倒是不少，特别是HBO的。。。），就在这时，那男的看到上铺的乘客的头悬在床边，惊醒了一车的人。</p><p>说到底就是突然发现自己的车厢中有具尸体，乘客都有啥反应。（额，那我上面为什么要说那么多。。。）其实有趣就有趣在这里，每个人物做出的的反应是如此真实，合情合理，但总感觉略有违和感。先来说医生Maxwell，他首先站出来说都别动，我是医生，在确认那人死后又出去找警卫，让其他人都别走。到这里，都没什么特别的，作为一个医生，这些都是常规操作。其次，说说那个胖叔叔，真正的Meyer医生，他下床后第一件事就是翻死者的口袋，找到了个钱包，里面有张家庭合照。显然，他已经当爷爷了，众人都感到惋惜。这时Maxwell医生回来了，说找不到人。没办法，这时候只能用紧急停止按钮了。</p><blockquote><p>。。。。。。桂桂，怎么写了辣么多了，这才第一集啊，后面怎么办哟。。。算了，后面不写那么详细了，难得写影评没想说的太多没收住。。。先这样吧，下次有空再更——2018/2/11</p></blockquote><h2 id="第2集"><a href="#第2集" class="headerlink" title="第2集"></a>第2集</h2><h2 id="第3集"><a href="#第3集" class="headerlink" title="第3集"></a>第3集</h2><h2 id="第4集"><a href="#第4集" class="headerlink" title="第4集"></a>第4集</h2><h2 id="第5集"><a href="#第5集" class="headerlink" title="第5集"></a>第5集</h2><h2 id="第6集"><a href="#第6集" class="headerlink" title="第6集"></a>第6集</h2>]]></content:encoded>
      
      <comments>https://DOOKNET.github.io/2018/02/11/%E5%BD%B1%E8%AF%84/%E3%80%8A9%E5%8F%B7%E7%A7%98%E4%BA%8B%E3%80%8B/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Matlab产生测试激励</title>
      <link>https://DOOKNET.github.io/2018/02/11/Matlab%E4%BA%A7%E7%94%9F%E6%B5%8B%E8%AF%95%E6%BF%80%E5%8A%B1/</link>
      <guid>https://DOOKNET.github.io/2018/02/11/Matlab%E4%BA%A7%E7%94%9F%E6%B5%8B%E8%AF%95%E6%BF%80%E5%8A%B1/</guid>
      <pubDate>Sun, 11 Feb 2018 06:44:06 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在FPGA开发过程中几乎都要用到仿真的功能，对于一些简单的外部激励（如时钟、复位、简单数据或者信号等）直接在testbench中编写产生就行
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在FPGA开发过程中几乎都要用到仿真的功能，对于一些简单的外部激励（如时钟、复位、简单数据或者信号等）直接在testbench中编写产生就行了，但对于复杂的外部激励数据，很难在testbench中产生，这时就要通过读取外部文件里的数据来实现。通过和matlab的配合使用，基本上可以模拟各种外部激励。<br>举例来说：输入信号是三个不同频率的正弦波的相加，经过FIR低通滤波器滤除高频分量，输出频率最低的那个正弦信号。这种情况下测试用的输入信号不能通过testbench编写产生。<br>简单来说有以下两种方法可以模拟输入信号：</p><ol><li>在FPGA内部通过DDS产生三个正弦波，然后将三个波形相加作为输入信号。</li><li>利用matlab产生输入信号，将数据导出为.txt文件，在仿真时读取文件内的数据作为外部激励。</li></ol><p>显然第二种方法更加灵活和便捷。下面，具体介绍一下这种方法的使用。</p><hr><h3 id="平台："><a href="#平台：" class="headerlink" title="平台："></a>平台：</h3><ul><li>Vivado 16.4</li><li>Matlab R2017b</li></ul><h3 id="Matlab程序编写："><a href="#Matlab程序编写：" class="headerlink" title="Matlab程序编写："></a>Matlab程序编写：</h3><ul><li>代码如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">%=============设置系统参数==============%</span><br><span class="line">f1=1e6;        %设置波形频率</span><br><span class="line">f2=500e3;</span><br><span class="line">f3=800e3;</span><br><span class="line">Fs=20e6;        %设置采样频率</span><br><span class="line">L=1024;         %数据长度</span><br><span class="line">N=14;           %数据位宽</span><br><span class="line">%=============产生输入信号==============%</span><br><span class="line">t=0:1/Fs:(1/Fs)*(L-1);</span><br><span class="line">y1=sin(2*pi*f1*t);</span><br><span class="line">y2=sin(2*pi*f2*t);</span><br><span class="line">y3=sin(2*pi*f3*t);</span><br><span class="line">y4=y1+y2+y3;</span><br><span class="line">y_n=round(y4*(2^(N-3)-1));      %N比特量化;如果有n个信号相加，则设置（N-n）</span><br><span class="line">%=================画图==================%</span><br><span class="line">a=10;           %改变系数可以调整显示周期</span><br><span class="line">stem(t,y_n);</span><br><span class="line">axis([0 L/Fs/a -2^N 2^N]);      %显示</span><br><span class="line">%=============写入外部文件==============%</span><br><span class="line">fid=fopen(&apos;E:\Workspace\Vivado_16.4\TEST\TestBench\sin_data.txt&apos;,&apos;w&apos;);    %把数据写入sin_data.txt文件中，如果没有就创建该文件</span><br><span class="line">for k=1:length(y_n)</span><br><span class="line">    B_s=dec2bin(y_n(k)+((y_n(k))&lt;0)*2^N,N);</span><br><span class="line">    for j=1:N</span><br><span class="line">        if B_s(j)==&apos;1&apos;</span><br><span class="line">            tb=1;</span><br><span class="line">        else</span><br><span class="line">            tb=0;</span><br><span class="line">        end</span><br><span class="line">        fprintf(fid,&apos;%d&apos;,tb);</span><br><span class="line">    end</span><br><span class="line">    fprintf(fid,&apos;\r\n&apos;);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">fprintf(fid,&apos;;&apos;);</span><br><span class="line">fclose(fid);</span><br></pre></td></tr></table></figure><p>此程序中设置了三个频率分别为1M、500k和800k的正弦波，然后将三个波形相加并且量化后作为输出。最后将路径设置为相应文件所在路径即可，需要注意的是如果对应路径下没有相应文件，则会自动新建文件并写入数据。</p><ul><li><p>运行程序：<br><img src="https://user-images.githubusercontent.com/29295862/35777703-4d3d1e6c-09ed-11e8-9c6f-3b6f9abd597b.png" alt=" "></p></li><li><p>打开对应的文件目录<br><img src="https://user-images.githubusercontent.com/29295862/35777708-51403d82-09ed-11e8-9cbe-41e84d961120.png" alt=" "><br>可以看到二进制数据文件已经生成。</p></li></ul><p>接下来就可以进行在testbench中读取外部数据的操作了。</p><h3 id="Testbench的编写："><a href="#Testbench的编写：" class="headerlink" title="Testbench的编写："></a>Testbench的编写：</h3><ul><li>代码如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">`timescale 1ns/1ps</span><br><span class="line"></span><br><span class="line">module TB_readfile();</span><br><span class="line">reg     SCLK;</span><br><span class="line">reg    [13:0]  data_out;</span><br><span class="line"></span><br><span class="line">//--------------时钟部分----------------//</span><br><span class="line">initial     SCLK = 0;</span><br><span class="line">always      #10     SCLK = ~SCLK;</span><br><span class="line"></span><br><span class="line">//-------------------------------------//</span><br><span class="line">parameter data_num = 32&apos;d1024;</span><br><span class="line">integer   i = 0;</span><br><span class="line">reg [13:0]  data_men[1:data_num];</span><br><span class="line">reg [13:0]  data_reg = 0;</span><br><span class="line">initial begin</span><br><span class="line">    $readmemb(&quot;E:/Workspace/Vivado_16.4/2017_8_28_TEST/TestBench/sin_data.txt&quot;,data_men);   //注意斜杠的方向，不能反&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span><br><span class="line">end</span><br><span class="line">always @(posedge SCLK) begin</span><br><span class="line">    data_out &lt;= data_men[i];</span><br><span class="line">    i &lt;= i + 8&apos;d1;</span><br><span class="line">end</span><br><span class="line">//------------------------------------//</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><p>因为这里只需要读取外部数据，所以Vivado工程里只需要添加仿真文件就行了。</p><ul><li>运行仿真：<br><img src="https://user-images.githubusercontent.com/29295862/35778030-52933256-09f3-11e8-87fc-56e030b5d9ba.png" alt=" "><br>可以看到，仿真的波形和matlab中显示的波形一致，说明结果正确。</li></ul><hr><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>Matlab可以说是个很强大的工具，在设计中合理的使用matlab可以起到事半功倍的效果。当然我也在不断的学习中，如果有疑问或者更好的想法欢迎交流。。。</p>]]></content:encoded>
      
      <comments>https://DOOKNET.github.io/2018/02/11/Matlab%E4%BA%A7%E7%94%9F%E6%B5%8B%E8%AF%95%E6%BF%80%E5%8A%B1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>AM解调的FPGA实现</title>
      <link>https://DOOKNET.github.io/2018/02/09/AM%E8%A7%A3%E8%B0%83%E7%9A%84FPGA%E5%AE%9E%E7%8E%B0/</link>
      <guid>https://DOOKNET.github.io/2018/02/09/AM%E8%A7%A3%E8%B0%83%E7%9A%84FPGA%E5%AE%9E%E7%8E%B0/</guid>
      <pubDate>Fri, 09 Feb 2018 11:13:38 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;一、说明：&quot;&gt;&lt;a href=&quot;#一、说明：&quot; class=&quot;headerlink&quot; title=&quot;一、说明：&quot;&gt;&lt;/a&gt;一、说明：&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;功能：AM解调&lt;/li&gt;
&lt;li&gt;平台：Vivado 2016.4 和 Matlab R2017a&lt;/l
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="一、说明："><a href="#一、说明：" class="headerlink" title="一、说明："></a>一、说明：</h2><ol><li>功能：AM解调</li><li>平台：Vivado 2016.4 和 Matlab R2017a</li></ol><h2 id="二、原理："><a href="#二、原理：" class="headerlink" title="二、原理："></a>二、原理：</h2><h3 id="1-AM解调原理"><a href="#1-AM解调原理" class="headerlink" title="1.AM解调原理"></a>1.AM解调原理</h3><ul><li><p><strong>模拟电路中采用“包络检波”的方法：</strong><br><img src="https://user-images.githubusercontent.com/29295862/35344975-615af3f6-0169-11e8-9d69-7cac3196baad.png" alt="这里写图片描述"></p></li><li><p><strong>数字电路中采用类似的方法：</strong><br>先将已调信号取绝对值，再经过低通滤波器，滤除高频分量（经AM调制的信号包含两个高频分量：载波频率+/-调制信号频率，因此低通滤波器的截止频率小于两个高频分量就可以），得到的就是叠加了直流分量的调制信号，去直流后便可以得到调制信号。</p></li></ul><h2 id="三、AM解调的FPGA实现"><a href="#三、AM解调的FPGA实现" class="headerlink" title="三、AM解调的FPGA实现"></a>三、AM解调的FPGA实现</h2><h3 id="1-将已调制的AM信号取绝对值"><a href="#1-将已调制的AM信号取绝对值" class="headerlink" title="1.将已调制的AM信号取绝对值"></a>1.将已调制的AM信号取绝对值</h3><p>关于AM信号的产生，参见上一篇博客：<a href="http://blog.csdn.net/hooknet/article/details/79129451" target="_blank" rel="noopener">AM调制的FPGA实现</a></p><p>简单说明一下对数据取反的思路：如果是无符号数，则不存在符号位，也就是说数据都是正数，不需要取绝对值；如果是有符号数，通过检测最高位的符号位，如果符号位是1，则表示数据是负数，对数据取反，如果符号位是0，则表示数据是正数，不需要取反操作。</p><ul><li><strong>取绝对值的Verilog实现：</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">always @(posedge clk or negedge rst_n) begin</span><br><span class="line">if(!rst_n)begin</span><br><span class="line">data_tdata &lt;= 0;</span><br><span class="line">end</span><br><span class="line">else if(AM_mod[15] == 1)begin</span><br><span class="line">data_tdata &lt;= -&#123;AM_mod&#125;;//如果符号位是1，对数据取反</span><br><span class="line">end</span><br><span class="line">else if(AM_mod[15] == 0)begin</span><br><span class="line">data_tdata &lt;= AM_mod;//如果符号位是0，数据不变</span><br><span class="line">end</span><br><span class="line">elsebegin</span><br><span class="line">data_tdata &lt;= data_tdata;</span><br><span class="line">end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="2-使用FIR滤波器滤除高频分量"><a href="#2-使用FIR滤波器滤除高频分量" class="headerlink" title="2.使用FIR滤波器滤除高频分量"></a>2.使用FIR滤波器滤除高频分量</h3><p>关于Vivado的FIR IP核可以说是功能很强大的，但这里不需要其他复杂的功能，只需要简单的生成一个的低通滤波器就行了。<br>类似于ROM核的生成，配置FIR同样需要Matlab配合。可见，Matlab的功能是多么强大。这里Matlab的主要作用是对滤波器的性能进行仿真并生成相应的抽头系数。</p><ul><li><p><strong>使用Matlab生成FIR的抽头系数</strong></p><p>在Matlab的命令行窗口输入：<strong>filterDesigner</strong>（以前是用fdatool命令，不过输入fdatool也可以，只是会提醒你改用新的命令）弹出滤波器设计窗口：<br><img src="https://user-images.githubusercontent.com/29295862/35436554-d89264fc-02c9-11e8-86a7-1a3ec42b38a4.png" alt=" "></p><p>接下来，对滤波器的一些参数进行设置：<br><img src="https://user-images.githubusercontent.com/29295862/35436558-dfcb81c2-02c9-11e8-9645-53b557b1e4dc.png" alt=" "></p><p>参数设置好后，点击<strong>Design Filter</strong> 按钮查看生成滤波器的幅频响应图，通过幅频响应等图来判断滤波器是否达到设计要求：<br><img src="https://user-images.githubusercontent.com/29295862/35436563-e5e15244-02c9-11e8-9182-5dfec6896191.png" alt=" "></p><p>设计的滤波器满足性能指标后需要将抽头系数导出，保存为.coe文件。在导出前需要对系数进行量化。因为需要解调的AM信号也是16位宽，所以这里的位宽设置保持默认值，这些可以根据实际情况自行修改。<br><img src="https://user-images.githubusercontent.com/29295862/35436570-eb25ca28-02c9-11e8-8883-bb954ca2632c.png" alt=" "></p><p>量化过后就能将抽头系数导出为.coe文件了：<br><img src="https://user-images.githubusercontent.com/29295862/35436572-ed8ba742-02c9-11e8-950d-d837242dc0c8.png" alt=" "></p></li><li><p><strong>生成FIR IP核</strong></p><p>IP核的具体配置如下：<br><img src="https://user-images.githubusercontent.com/29295862/35437697-9211cfe0-02ce-11e8-8952-72d5271b127f.png" alt=" "><br><img src="https://user-images.githubusercontent.com/29295862/35437699-927806de-02ce-11e8-97fa-89c4f899561c.png" alt=" "><br><img src="https://user-images.githubusercontent.com/29295862/35437700-92dc2ed4-02ce-11e8-8ba7-9b9bb82c8b15.png" alt=" "></p><p>其他保持默认即可：<br><img src="https://user-images.githubusercontent.com/29295862/35437701-933df1dc-02ce-11e8-854a-abd7a0fb4038.png" alt=" "><br><img src="https://user-images.githubusercontent.com/29295862/35437702-93c467f8-02ce-11e8-8c03-142055f69c5e.png" alt=" "></p><p>同样，在IP核配置界面也可以查看滤波器的幅频特性：<br><img src="https://user-images.githubusercontent.com/29295862/35437703-942511ac-02ce-11e8-94e0-809114c09697.png" alt=" "></p></li></ul><p>IP核生成完毕后，就可以编写IP核的调用模块了。</p><ul><li><strong>FIR IP核调用模块：</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">module FIR_Control(</span><br><span class="line">inputclk,</span><br><span class="line">inputrst_n,</span><br><span class="line">inputsigned[15:0]s_axis_data_tdata,</span><br><span class="line">outputreg [7:0]data_out</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">wire s_axis_data_tready;</span><br><span class="line">wirem_axis_data_tvalid;</span><br><span class="line">wire [39:0]m_axis_data_tdata;//滤波器输出信号</span><br><span class="line"></span><br><span class="line">always @(posedge clk or negedge rst_n) begin</span><br><span class="line">if(!rst_n)begin</span><br><span class="line">data_out &lt;= 0;</span><br><span class="line">end</span><br><span class="line">elsebegin</span><br><span class="line">data_out &lt;= m_axis_data_tdata[33:26];//根据仿真结果进行截位</span><br><span class="line">end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">//--------------调用FIR核----------------//</span><br><span class="line">FIRFIR_inst0(</span><br><span class="line">  .aclk(clk),</span><br><span class="line">  .s_axis_data_tvalid(1),//拉高时IP核开始工作</span><br><span class="line">  .s_axis_data_tready(s_axis_data_tready),</span><br><span class="line">  .s_axis_data_tdata(s_axis_data_tdata),//输入信号</span><br><span class="line">  .m_axis_data_tvalid(m_axis_data_tvalid),//拉高时表明数据输出有效</span><br><span class="line">  .m_axis_data_tdata(m_axis_data_tdata)//输出信号</span><br><span class="line">);</span><br><span class="line">//---------------------------------------//</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><p>需要注意的是：<br><strong>m_axis_data_tdata</strong> 信号是滤波器的数据输出信号，我们在使用时一般都要对此数据进行截位操作，如何进行截位需要根据仿真结果来确定。比如，在这个工程中，我需要的滤波器的输出数据是8位，但不能一下子截取高8位，而且<strong>m_axis_data_tdata</strong>是个40位的数据，从仿真波形来看<strong>m_axis_data_tdata</strong>[39:34]都是符号位，因此从33位开始往下截取8位数据（当然也可以从34位开始截，这样的话就多了一位符号位，相应的数据位就变少了一位）。</p><h3 id="3-去直流处理"><a href="#3-去直流处理" class="headerlink" title="3.去直流处理"></a>3.去直流处理</h3><p>经过FIR滤波后的波形其实就是一个叠加了直流分量的调制信号。在本工程中，AM调制是100%调制，也就是说解调时经过FIR后的信号的最小值为0，可以把它看作是无符号的数，直接经DA输出就行了。<br>如果不是100%调制呢？也就是说解调时经过FIR后的信号的最小值是大于0的，那么这个大于0的量就相当于直流，需要去掉后再经DA输出。<br>因此，在这个工程中，不需要去直流处理。下面给出顶层文件的代码。</p><ul><li><strong>顶层模块编写：</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">module TOP(</span><br><span class="line">inputclk,</span><br><span class="line">inputrst_n,</span><br><span class="line">output[7:0]AM_demod</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">//--------------------------------//</span><br><span class="line">reg signed[15:0]data_tdata;</span><br><span class="line">wire signed[15:0]AM_mod;</span><br><span class="line">//--------------------------------//</span><br><span class="line"></span><br><span class="line">//-----------取绝对值-------------//</span><br><span class="line">always @(posedge clk or negedge rst_n) begin</span><br><span class="line">if(!rst_n)begin</span><br><span class="line">data_tdata &lt;= 0;</span><br><span class="line">end</span><br><span class="line">else if(AM_mod[15] == 1)begin</span><br><span class="line">data_tdata &lt;= -&#123;AM_mod&#125;;//如果符号位是1，对数据取反</span><br><span class="line">end</span><br><span class="line">else if(AM_mod[15] == 0)begin</span><br><span class="line">data_tdata &lt;= AM_mod;//如果符号位是0，数据不变</span><br><span class="line">end</span><br><span class="line">elsebegin</span><br><span class="line">data_tdata &lt;= data_tdata;</span><br><span class="line">end</span><br><span class="line">end</span><br><span class="line">//--------------------------------//</span><br><span class="line"></span><br><span class="line">//-----------AM已调信号------------//</span><br><span class="line">modulatemodulate_inst0(</span><br><span class="line">.clk(clk),</span><br><span class="line">.rst_n(rst_n),</span><br><span class="line">.AM_mod(AM_mod)</span><br><span class="line">);</span><br><span class="line">//--------------------------------//</span><br><span class="line"></span><br><span class="line">//----------滤波器控制模块---------//</span><br><span class="line">FIR_ControlFIR_Control_inst2(</span><br><span class="line">.clk(clk),</span><br><span class="line">.rst_n(rst_n),</span><br><span class="line">.s_axis_data_tdata(data_tdata),</span><br><span class="line">.data_out(AM_demod)</span><br><span class="line">);</span><br><span class="line">//--------------------------------//</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><h3 id="4-解调仿真"><a href="#4-解调仿真" class="headerlink" title="4.解调仿真"></a>4.解调仿真</h3><ul><li><strong>编写TestBeach：</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">`timescale 1ns/1ps</span><br><span class="line"></span><br><span class="line">module tb_AM();</span><br><span class="line"></span><br><span class="line">//===================解调部分====================//</span><br><span class="line">//----------接口设置----------//</span><br><span class="line">reg sclk;</span><br><span class="line">regrst_n;</span><br><span class="line">wire [7:0]AM_demod;</span><br><span class="line">//--------------------------//</span><br><span class="line">initialsclk = 1;</span><br><span class="line">always#5sclk = ~sclk;//100M时钟</span><br><span class="line"></span><br><span class="line">initialbegin</span><br><span class="line">rst_n = 0;</span><br><span class="line">#500</span><br><span class="line">rst_n = 1;</span><br><span class="line">end</span><br><span class="line">//----------解调模块----------//</span><br><span class="line">TOPTOP_inst(</span><br><span class="line">.clk(sclk),</span><br><span class="line">.rst_n(rst_n),</span><br><span class="line">.AM_demod(AM_demod)</span><br><span class="line">);</span><br><span class="line">//---------------------------//</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><ul><li><p><strong>仿真结果</strong></p><p><img src="https://user-images.githubusercontent.com/29295862/35448887-7a2c7452-02f6-11e8-91ce-0253953ac892.png" alt=" "></p></li></ul><p>由仿真结果可知，最终输出信号正确还原了已调制信号的包络，表明解调正确。</p>]]></content:encoded>
      
      <comments>https://DOOKNET.github.io/2018/02/09/AM%E8%A7%A3%E8%B0%83%E7%9A%84FPGA%E5%AE%9E%E7%8E%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>AM调制的FPGA实现</title>
      <link>https://DOOKNET.github.io/2018/02/09/AM%E8%B0%83%E5%88%B6%E7%9A%84FPGA%E5%AE%9E%E7%8E%B0/</link>
      <guid>https://DOOKNET.github.io/2018/02/09/AM%E8%B0%83%E5%88%B6%E7%9A%84FPGA%E5%AE%9E%E7%8E%B0/</guid>
      <pubDate>Fri, 09 Feb 2018 11:05:44 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;一、说明：&quot;&gt;&lt;a href=&quot;#一、说明：&quot; class=&quot;headerlink&quot; title=&quot;一、说明：&quot;&gt;&lt;/a&gt;一、说明：&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;功能：AM调制&lt;/li&gt;
&lt;li&gt;平台：Vivado 2016.4 和 Matlab R2017a&lt;/l
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="一、说明："><a href="#一、说明：" class="headerlink" title="一、说明："></a>一、说明：</h2><ol><li>功能：AM调制</li><li>平台：Vivado 2016.4 和 Matlab R2017a</li></ol><h2 id="二、原理："><a href="#二、原理：" class="headerlink" title="二、原理："></a>二、原理：</h2><h3 id="1-AM调制原理"><a href="#1-AM调制原理" class="headerlink" title="1. AM调制原理"></a>1. AM调制原理</h3><ul><li><p><strong>AM已调信号的时域表达式：</strong><br><img src="https://user-images.githubusercontent.com/29295862/35344947-5391bf16-0169-11e8-97c9-d8eedace8214.png" alt=" "></p></li><li><p><strong>已调信号的频域表达式：</strong><br><img src="https://user-images.githubusercontent.com/29295862/35344965-5af1843a-0169-11e8-8404-a27227df6875.png" alt=" "><br>本质上AM调制就是频谱的搬移。</p></li><li><p><strong>AM调制的系统框图</strong><br><img src="https://user-images.githubusercontent.com/29295862/35344973-5f419bc4-0169-11e8-9397-0813d525fd8b.png" alt=" "><br>将调制信号加上一个直流分量，保证信号的最小值大于零，然后再和载波相乘，得到已调信号。</p></li></ul><h2 id="三、AM调制的FPGA实现"><a href="#三、AM调制的FPGA实现" class="headerlink" title="三、AM调制的FPGA实现"></a>三、AM调制的FPGA实现</h2><h3 id="1-产生调制信号和载波信号"><a href="#1-产生调制信号和载波信号" class="headerlink" title="1.产生调制信号和载波信号"></a>1.产生调制信号和载波信号</h3><p>调用ROM IP核在FPGA内部产生两路余弦信号，其中一路信号用于模拟外部输入的调制信号，另一路用作载波信号。<br>在配置ROM IP核之前，需要用Matlab生.coe文件，存放在ROM核里。</p><ul><li><strong>Matlab生成.coe文件：</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">%---------------------------------%</span><br><span class="line">width=8;       %设置rom的位宽</span><br><span class="line">depth=1024;     %设置rom的深度</span><br><span class="line">%---------------------------------%</span><br><span class="line"></span><br><span class="line">x=linspace(0,2*pi,depth);       %在一个周期内产生depth个采样点</span><br><span class="line">y_cos=cos(x);                   %生成余弦函数</span><br><span class="line">%y_cos=sin(x);                   %生成正弦函数</span><br><span class="line">%y_cos=round(y_cos*(2^(width-1)-1))+2^(width-1)-1;       %将数据转化成整数,生成无符号数</span><br><span class="line">y_cos=round(y_cos*(2^(width-1)-1));       %将数据转化成整数,生成有符号数</span><br><span class="line"></span><br><span class="line">plot(x,y_cos);                  %绘图</span><br><span class="line"></span><br><span class="line">fid = fopen(&apos;E:\Workspace\DDS\Design\IP_Core\cos.coe&apos;,&apos;wt&apos;);</span><br><span class="line"></span><br><span class="line">fprintf(fid,&apos;memory_initialization_radix = 10;\nmemory_initialization_vector = &apos;);</span><br><span class="line">for i = 1 : depth</span><br><span class="line">    if mod(i-1,8) == 0 </span><br><span class="line">        fprintf(fid,&apos;\n&apos;);</span><br><span class="line">    end</span><br><span class="line">    fprintf(fid,&apos;%6d,&apos;,y_cos(i));</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">fclose(fid);                    %关闭文件</span><br></pre></td></tr></table></figure><p>生成.coe文件后就可以进行IP核的配置了。</p><ul><li><strong>ROM核具体配置：</strong><br><img src="https://user-images.githubusercontent.com/29295862/35349621-6e1186ac-0176-11e8-98e5-a1475ff60d50.png" alt=" "><br><img src="https://user-images.githubusercontent.com/29295862/35349629-739fdf24-0176-11e8-800e-aea80c15a60d.png" alt=" "><br><img src="https://user-images.githubusercontent.com/29295862/35349637-77da1834-0176-11e8-8b3a-e1ce6b8441a5.png" alt=" "><br><img src="https://user-images.githubusercontent.com/29295862/35349644-7c3bb8ec-0176-11e8-9acc-f9033ad57396.png" alt=" "></li></ul><p>配置完IP核后，编写控制模块，产生两路信号。其中，调制信号上叠加的直流分量的大小为调制信号的峰值，这样将得到调制度为100%的已调信号。如果要得到不同的调制度，则需要叠加不同大小的直流分量，同时需要注意定义的数据位宽，防止数据溢出。</p><ul><li><strong>产生载波和带有直流分量的调制信号：</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">module cos_make(</span><br><span class="line">inputclk,</span><br><span class="line">inputrst_n,</span><br><span class="line">outputreg[7:0]cos_s,</span><br><span class="line">outputregsigned[7:0]cos_c</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">//------------------------------------//</span><br><span class="line">parameter freq_s = 32&apos;d429497;//调制信号频率10k</span><br><span class="line">parameter freq_c = 32&apos;d42949673;//载波频率1M</span><br><span class="line">parameter cnt_width = 8&apos;d32;</span><br><span class="line">//------------------------------------//</span><br><span class="line"></span><br><span class="line">//------------------------------------//</span><br><span class="line">reg [cnt_width-1:0]cnt_s = 0;</span><br><span class="line">reg[cnt_width-1:0]cnt_c = 0;</span><br><span class="line">wire [9:0]addr_s;</span><br><span class="line">wire[9:0]addr_c;</span><br><span class="line">always @(posedge clk or negedge rst_n) begin</span><br><span class="line">if(!rst_n)begin</span><br><span class="line">cnt_s &lt;= 0;</span><br><span class="line">cnt_c &lt;= 0;</span><br><span class="line">end</span><br><span class="line">elsebegin</span><br><span class="line">cnt_s &lt;= cnt_s + freq_s;</span><br><span class="line">cnt_c &lt;= cnt_c + freq_c;</span><br><span class="line">end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">assignaddr_s = cnt_s[cnt_width-1:cnt_width-10];</span><br><span class="line">assignaddr_c = cnt_c[cnt_width-1:cnt_width-10];</span><br><span class="line">//------------------------------------//</span><br><span class="line"></span><br><span class="line">//------------调用ROM核----------------//</span><br><span class="line">wire signed[7:0]cos_s_r;</span><br><span class="line">wire signed[7:0]cos_c_r;</span><br><span class="line"></span><br><span class="line">ROMROM_inst(</span><br><span class="line">.clka(clk),</span><br><span class="line">.addra(addr_s),</span><br><span class="line">.douta(cos_s_r),</span><br><span class="line">.clkb(clk),</span><br><span class="line">.addrb(addr_c),</span><br><span class="line">.doutb(cos_c_r)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">always @(posedge clk or negedge rst_n) begin</span><br><span class="line">if(!rst_n)begin</span><br><span class="line">cos_s &lt;= 0;</span><br><span class="line">cos_c &lt;= 0;</span><br><span class="line">end</span><br><span class="line">elsebegin</span><br><span class="line">cos_s &lt;= cos_s_r + 8 &apos;d128;//加上大小为峰值的直流分量</span><br><span class="line">cos_c &lt;= cos_c_r;</span><br><span class="line">end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><h3 id="2-生成AM调制信号"><a href="#2-生成AM调制信号" class="headerlink" title="2.生成AM调制信号"></a>2.生成AM调制信号</h3><p>得到两路信号后就可以用乘法器将两路信号相乘，得到已调信号。</p><ul><li><p><strong>乘法器具体配置：</strong><br><img src="https://user-images.githubusercontent.com/29295862/35351304-722b11ea-017b-11e8-8fbe-fa55d56b9e0c.png" alt=" "><br><img src="https://user-images.githubusercontent.com/29295862/35351309-76a5fee2-017b-11e8-876f-0c74fc15beab.png" alt=" "></p></li><li><p><strong>AM调制的顶层模块：</strong></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">module modulate(</span><br><span class="line">inputclk,</span><br><span class="line">inputrst_n,</span><br><span class="line">outputsigned[15:0]AM_mod</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">wire [7:0]cos_s;</span><br><span class="line">wiresigned[7:0]cos_c;</span><br><span class="line"></span><br><span class="line">//------------调用出波模块------------//</span><br><span class="line">cos_makecos_make_inst0(</span><br><span class="line">.clk(clk),</span><br><span class="line">.rst_n(rst_n),</span><br><span class="line">.cos_s(cos_s),</span><br><span class="line">.cos_c(cos_c)</span><br><span class="line">);</span><br><span class="line">//-----------------------------------//</span><br><span class="line"></span><br><span class="line">//------------调用乘法器--------------//</span><br><span class="line">MULTMULT_inst1(</span><br><span class="line">  .CLK(clk),</span><br><span class="line">  .A(cos_s),</span><br><span class="line">  .B(cos_c),</span><br><span class="line">  .P(AM_mod)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><h3 id="3-仿真调制结果"><a href="#3-仿真调制结果" class="headerlink" title="3.仿真调制结果"></a>3.仿真调制结果</h3><p>以上AM调制过程基本完成，但是正确与否还需要通过仿真来确定，接下来编写仿真用的测试模块。</p><ul><li><strong>TestBeach的编写：</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">`timescale 1ns/1ps</span><br><span class="line"></span><br><span class="line">module tb_AM();</span><br><span class="line"></span><br><span class="line">//---------接口设置----------//</span><br><span class="line">reg sclk;</span><br><span class="line">regrst_n;</span><br><span class="line">wire signed[15:0]AM_mod;</span><br><span class="line">//--------------------------//</span><br><span class="line">initialsclk = 1;</span><br><span class="line">always#5sclk = ~sclk;//100M时钟</span><br><span class="line"></span><br><span class="line">initialbegin</span><br><span class="line">rst_n = 0;</span><br><span class="line">#500</span><br><span class="line">rst_n = 1;</span><br><span class="line">end</span><br><span class="line">//--------------------------//</span><br><span class="line">modulatemodulate_inst0(</span><br><span class="line">.clk(sclk),</span><br><span class="line">.rst_n(rst_n),</span><br><span class="line">.AM_mod(AM_mod)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><p>在Vivado中将各个文件添加进工程后，运行仿真。</p><ul><li><strong>仿真结果如下：</strong><br><img src="https://user-images.githubusercontent.com/29295862/35352112-d7de9514-017d-11e8-8bfc-bb974be7840c.png" alt=" "><br><img src="https://user-images.githubusercontent.com/29295862/35352115-da652410-017d-11e8-8d84-881a1c2af51f.png" alt=" "></li></ul><p>已调信号能明显看到包络，并且包络的频率同调制信号一致，表明AM调制正确。</p>]]></content:encoded>
      
      <comments>https://DOOKNET.github.io/2018/02/09/AM%E8%B0%83%E5%88%B6%E7%9A%84FPGA%E5%AE%9E%E7%8E%B0/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
