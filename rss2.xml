<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>DOOKNET.Blog</title>
    <link>https://DOOKNET.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>但行好事，莫问前程</description>
    <pubDate>Fri, 09 Feb 2018 11:25:57 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>AM解调的FPGA实现</title>
      <link>https://DOOKNET.github.io/2018/02/09/AM%E8%A7%A3%E8%B0%83%E7%9A%84FPGA%E5%AE%9E%E7%8E%B0/</link>
      <guid>https://DOOKNET.github.io/2018/02/09/AM%E8%A7%A3%E8%B0%83%E7%9A%84FPGA%E5%AE%9E%E7%8E%B0/</guid>
      <pubDate>Fri, 09 Feb 2018 11:13:38 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;一、说明：&quot;&gt;&lt;a href=&quot;#一、说明：&quot; class=&quot;headerlink&quot; title=&quot;一、说明：&quot;&gt;&lt;/a&gt;一、说明：&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;功能：AM解调&lt;/li&gt;
&lt;li&gt;平台：Vivado 2016.4 和 Matlab R2017a&lt;/l
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="一、说明："><a href="#一、说明：" class="headerlink" title="一、说明："></a>一、说明：</h2><ol><li>功能：AM解调</li><li>平台：Vivado 2016.4 和 Matlab R2017a</li></ol><h2 id="二、原理："><a href="#二、原理：" class="headerlink" title="二、原理："></a>二、原理：</h2><h3 id="1-AM解调原理"><a href="#1-AM解调原理" class="headerlink" title="1.AM解调原理"></a>1.AM解调原理</h3><ul><li><p><strong>模拟电路中采用“包络检波”的方法：</strong><br><img src="https://user-images.githubusercontent.com/29295862/35344975-615af3f6-0169-11e8-9d69-7cac3196baad.png" alt="这里写图片描述"></p></li><li><p><strong>数字电路中采用类似的方法：</strong><br>先将已调信号取绝对值，再经过低通滤波器，滤除高频分量（经AM调制的信号包含两个高频分量：载波频率+/-调制信号频率，因此低通滤波器的截止频率小于两个高频分量就可以），得到的就是叠加了直流分量的调制信号，去直流后便可以得到调制信号。</p></li></ul><h2 id="三、AM解调的FPGA实现"><a href="#三、AM解调的FPGA实现" class="headerlink" title="三、AM解调的FPGA实现"></a>三、AM解调的FPGA实现</h2><h3 id="1-将已调制的AM信号取绝对值"><a href="#1-将已调制的AM信号取绝对值" class="headerlink" title="1.将已调制的AM信号取绝对值"></a>1.将已调制的AM信号取绝对值</h3><p>关于AM信号的产生，参见上一篇博客：<a href="http://blog.csdn.net/hooknet/article/details/79129451" target="_blank" rel="noopener">AM调制的FPGA实现</a></p><p>简单说明一下对数据取反的思路：如果是无符号数，则不存在符号位，也就是说数据都是正数，不需要取绝对值；如果是有符号数，通过检测最高位的符号位，如果符号位是1，则表示数据是负数，对数据取反，如果符号位是0，则表示数据是正数，不需要取反操作。</p><ul><li><strong>取绝对值的Verilog实现：</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">always @(posedge clk or negedge rst_n) begin</span><br><span class="line">if(!rst_n)begin</span><br><span class="line">data_tdata &lt;= 0;</span><br><span class="line">end</span><br><span class="line">else if(AM_mod[15] == 1)begin</span><br><span class="line">data_tdata &lt;= -&#123;AM_mod&#125;;//如果符号位是1，对数据取反</span><br><span class="line">end</span><br><span class="line">else if(AM_mod[15] == 0)begin</span><br><span class="line">data_tdata &lt;= AM_mod;//如果符号位是0，数据不变</span><br><span class="line">end</span><br><span class="line">elsebegin</span><br><span class="line">data_tdata &lt;= data_tdata;</span><br><span class="line">end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="2-使用FIR滤波器滤除高频分量"><a href="#2-使用FIR滤波器滤除高频分量" class="headerlink" title="2.使用FIR滤波器滤除高频分量"></a>2.使用FIR滤波器滤除高频分量</h3><p>关于Vivado的FIR IP核可以说是功能很强大的，但这里不需要其他复杂的功能，只需要简单的生成一个的低通滤波器就行了。<br>类似于ROM核的生成，配置FIR同样需要Matlab配合。可见，Matlab的功能是多么强大。这里Matlab的主要作用是对滤波器的性能进行仿真并生成相应的抽头系数。</p><ul><li><p><strong>使用Matlab生成FIR的抽头系数</strong></p><p>在Matlab的命令行窗口输入：<strong>filterDesigner</strong>（以前是用fdatool命令，不过输入fdatool也可以，只是会提醒你改用新的命令）弹出滤波器设计窗口：<br><img src="https://user-images.githubusercontent.com/29295862/35436554-d89264fc-02c9-11e8-86a7-1a3ec42b38a4.png" alt=" "></p><p>接下来，对滤波器的一些参数进行设置：<br><img src="https://user-images.githubusercontent.com/29295862/35436558-dfcb81c2-02c9-11e8-9645-53b557b1e4dc.png" alt=" "></p><p>参数设置好后，点击<strong>Design Filter</strong> 按钮查看生成滤波器的幅频响应图，通过幅频响应等图来判断滤波器是否达到设计要求：<br><img src="https://user-images.githubusercontent.com/29295862/35436563-e5e15244-02c9-11e8-9182-5dfec6896191.png" alt=" "></p><p>设计的滤波器满足性能指标后需要将抽头系数导出，保存为.coe文件。在导出前需要对系数进行量化。因为需要解调的AM信号也是16位宽，所以这里的位宽设置保持默认值，这些可以根据实际情况自行修改。<br><img src="https://user-images.githubusercontent.com/29295862/35436570-eb25ca28-02c9-11e8-8883-bb954ca2632c.png" alt=" "></p><p>量化过后就能将抽头系数导出为.coe文件了：<br><img src="https://user-images.githubusercontent.com/29295862/35436572-ed8ba742-02c9-11e8-950d-d837242dc0c8.png" alt=" "></p></li><li><p><strong>生成FIR IP核</strong></p><p>IP核的具体配置如下：<br><img src="https://user-images.githubusercontent.com/29295862/35437697-9211cfe0-02ce-11e8-8952-72d5271b127f.png" alt=" "><br><img src="https://user-images.githubusercontent.com/29295862/35437699-927806de-02ce-11e8-97fa-89c4f899561c.png" alt=" "><br><img src="https://user-images.githubusercontent.com/29295862/35437700-92dc2ed4-02ce-11e8-8ba7-9b9bb82c8b15.png" alt=" "></p><p>其他保持默认即可：<br><img src="https://user-images.githubusercontent.com/29295862/35437701-933df1dc-02ce-11e8-854a-abd7a0fb4038.png" alt=" "><br><img src="https://user-images.githubusercontent.com/29295862/35437702-93c467f8-02ce-11e8-8c03-142055f69c5e.png" alt=" "></p><p>同样，在IP核配置界面也可以查看滤波器的幅频特性：<br><img src="https://user-images.githubusercontent.com/29295862/35437703-942511ac-02ce-11e8-94e0-809114c09697.png" alt=" "></p></li></ul><p>IP核生成完毕后，就可以编写IP核的调用模块了。</p><ul><li><strong>FIR IP核调用模块：</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">module FIR_Control(</span><br><span class="line">inputclk,</span><br><span class="line">inputrst_n,</span><br><span class="line">inputsigned[15:0]s_axis_data_tdata,</span><br><span class="line">outputreg [7:0]data_out</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">wire s_axis_data_tready;</span><br><span class="line">wirem_axis_data_tvalid;</span><br><span class="line">wire [39:0]m_axis_data_tdata;//滤波器输出信号</span><br><span class="line"></span><br><span class="line">always @(posedge clk or negedge rst_n) begin</span><br><span class="line">if(!rst_n)begin</span><br><span class="line">data_out &lt;= 0;</span><br><span class="line">end</span><br><span class="line">elsebegin</span><br><span class="line">data_out &lt;= m_axis_data_tdata[33:26];//根据仿真结果进行截位</span><br><span class="line">end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">//--------------调用FIR核----------------//</span><br><span class="line">FIRFIR_inst0(</span><br><span class="line">  .aclk(clk),</span><br><span class="line">  .s_axis_data_tvalid(1),//拉高时IP核开始工作</span><br><span class="line">  .s_axis_data_tready(s_axis_data_tready),</span><br><span class="line">  .s_axis_data_tdata(s_axis_data_tdata),//输入信号</span><br><span class="line">  .m_axis_data_tvalid(m_axis_data_tvalid),//拉高时表明数据输出有效</span><br><span class="line">  .m_axis_data_tdata(m_axis_data_tdata)//输出信号</span><br><span class="line">);</span><br><span class="line">//---------------------------------------//</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><p>需要注意的是：<br><strong>m_axis_data_tdata</strong> 信号是滤波器的数据输出信号，我们在使用时一般都要对此数据进行截位操作，如何进行截位需要根据仿真结果来确定。比如，在这个工程中，我需要的滤波器的输出数据是8位，但不能一下子截取高8位，而且<strong>m_axis_data_tdata</strong>是个40位的数据，从仿真波形来看<strong>m_axis_data_tdata</strong>[39:34]都是符号位，因此从33位开始往下截取8位数据（当然也可以从34位开始截，这样的话就多了一位符号位，相应的数据位就变少了一位）。</p><h3 id="3-去直流处理"><a href="#3-去直流处理" class="headerlink" title="3.去直流处理"></a>3.去直流处理</h3><p>经过FIR滤波后的波形其实就是一个叠加了直流分量的调制信号。在本工程中，AM调制是100%调制，也就是说解调时经过FIR后的信号的最小值为0，可以把它看作是无符号的数，直接经DA输出就行了。<br>如果不是100%调制呢？也就是说解调时经过FIR后的信号的最小值是大于0的，那么这个大于0的量就相当于直流，需要去掉后再经DA输出。<br>因此，在这个工程中，不需要去直流处理。下面给出顶层文件的代码。</p><ul><li><strong>顶层模块编写：</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">module TOP(</span><br><span class="line">inputclk,</span><br><span class="line">inputrst_n,</span><br><span class="line">output[7:0]AM_demod</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">//--------------------------------//</span><br><span class="line">reg signed[15:0]data_tdata;</span><br><span class="line">wire signed[15:0]AM_mod;</span><br><span class="line">//--------------------------------//</span><br><span class="line"></span><br><span class="line">//-----------取绝对值-------------//</span><br><span class="line">always @(posedge clk or negedge rst_n) begin</span><br><span class="line">if(!rst_n)begin</span><br><span class="line">data_tdata &lt;= 0;</span><br><span class="line">end</span><br><span class="line">else if(AM_mod[15] == 1)begin</span><br><span class="line">data_tdata &lt;= -&#123;AM_mod&#125;;//如果符号位是1，对数据取反</span><br><span class="line">end</span><br><span class="line">else if(AM_mod[15] == 0)begin</span><br><span class="line">data_tdata &lt;= AM_mod;//如果符号位是0，数据不变</span><br><span class="line">end</span><br><span class="line">elsebegin</span><br><span class="line">data_tdata &lt;= data_tdata;</span><br><span class="line">end</span><br><span class="line">end</span><br><span class="line">//--------------------------------//</span><br><span class="line"></span><br><span class="line">//-----------AM已调信号------------//</span><br><span class="line">modulatemodulate_inst0(</span><br><span class="line">.clk(clk),</span><br><span class="line">.rst_n(rst_n),</span><br><span class="line">.AM_mod(AM_mod)</span><br><span class="line">);</span><br><span class="line">//--------------------------------//</span><br><span class="line"></span><br><span class="line">//----------滤波器控制模块---------//</span><br><span class="line">FIR_ControlFIR_Control_inst2(</span><br><span class="line">.clk(clk),</span><br><span class="line">.rst_n(rst_n),</span><br><span class="line">.s_axis_data_tdata(data_tdata),</span><br><span class="line">.data_out(AM_demod)</span><br><span class="line">);</span><br><span class="line">//--------------------------------//</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><h3 id="4-解调仿真"><a href="#4-解调仿真" class="headerlink" title="4.解调仿真"></a>4.解调仿真</h3><ul><li><strong>编写TestBeach：</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">`timescale 1ns/1ps</span><br><span class="line"></span><br><span class="line">module tb_AM();</span><br><span class="line"></span><br><span class="line">//===================解调部分====================//</span><br><span class="line">//----------接口设置----------//</span><br><span class="line">reg sclk;</span><br><span class="line">regrst_n;</span><br><span class="line">wire [7:0]AM_demod;</span><br><span class="line">//--------------------------//</span><br><span class="line">initialsclk = 1;</span><br><span class="line">always#5sclk = ~sclk;//100M时钟</span><br><span class="line"></span><br><span class="line">initialbegin</span><br><span class="line">rst_n = 0;</span><br><span class="line">#500</span><br><span class="line">rst_n = 1;</span><br><span class="line">end</span><br><span class="line">//----------解调模块----------//</span><br><span class="line">TOPTOP_inst(</span><br><span class="line">.clk(sclk),</span><br><span class="line">.rst_n(rst_n),</span><br><span class="line">.AM_demod(AM_demod)</span><br><span class="line">);</span><br><span class="line">//---------------------------//</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><ul><li><p><strong>仿真结果</strong></p><p><img src="https://user-images.githubusercontent.com/29295862/35448887-7a2c7452-02f6-11e8-91ce-0253953ac892.png" alt=" "></p></li></ul><p>由仿真结果可知，最终输出信号正确还原了已调制信号的包络，表明解调正确。</p>]]></content:encoded>
      
      <comments>https://DOOKNET.github.io/2018/02/09/AM%E8%A7%A3%E8%B0%83%E7%9A%84FPGA%E5%AE%9E%E7%8E%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>AM调制的FPGA实现</title>
      <link>https://DOOKNET.github.io/2018/02/09/AM%E8%B0%83%E5%88%B6%E7%9A%84FPGA%E5%AE%9E%E7%8E%B0/</link>
      <guid>https://DOOKNET.github.io/2018/02/09/AM%E8%B0%83%E5%88%B6%E7%9A%84FPGA%E5%AE%9E%E7%8E%B0/</guid>
      <pubDate>Fri, 09 Feb 2018 11:05:44 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;一、说明：&quot;&gt;&lt;a href=&quot;#一、说明：&quot; class=&quot;headerlink&quot; title=&quot;一、说明：&quot;&gt;&lt;/a&gt;一、说明：&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;功能：AM调制&lt;/li&gt;
&lt;li&gt;平台：Vivado 2016.4 和 Matlab R2017a&lt;/l
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="一、说明："><a href="#一、说明：" class="headerlink" title="一、说明："></a>一、说明：</h2><ol><li>功能：AM调制</li><li>平台：Vivado 2016.4 和 Matlab R2017a</li></ol><h2 id="二、原理："><a href="#二、原理：" class="headerlink" title="二、原理："></a>二、原理：</h2><h3 id="1-AM调制原理"><a href="#1-AM调制原理" class="headerlink" title="1. AM调制原理"></a>1. AM调制原理</h3><ul><li><p><strong>AM已调信号的时域表达式：</strong><br><img src="https://user-images.githubusercontent.com/29295862/35344947-5391bf16-0169-11e8-97c9-d8eedace8214.png" alt=" "></p></li><li><p><strong>已调信号的频域表达式：</strong><br><img src="https://user-images.githubusercontent.com/29295862/35344965-5af1843a-0169-11e8-8404-a27227df6875.png" alt=" "><br>本质上AM调制就是频谱的搬移。</p></li><li><p><strong>AM调制的系统框图</strong><br><img src="https://user-images.githubusercontent.com/29295862/35344973-5f419bc4-0169-11e8-9397-0813d525fd8b.png" alt=" "><br>将调制信号加上一个直流分量，保证信号的最小值大于零，然后再和载波相乘，得到已调信号。</p></li></ul><h2 id="三、AM调制的FPGA实现"><a href="#三、AM调制的FPGA实现" class="headerlink" title="三、AM调制的FPGA实现"></a>三、AM调制的FPGA实现</h2><h3 id="1-产生调制信号和载波信号"><a href="#1-产生调制信号和载波信号" class="headerlink" title="1.产生调制信号和载波信号"></a>1.产生调制信号和载波信号</h3><p>调用ROM IP核在FPGA内部产生两路余弦信号，其中一路信号用于模拟外部输入的调制信号，另一路用作载波信号。<br>在配置ROM IP核之前，需要用Matlab生.coe文件，存放在ROM核里。</p><ul><li><strong>Matlab生成.coe文件：</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">%---------------------------------%</span><br><span class="line">width=8;       %设置rom的位宽</span><br><span class="line">depth=1024;     %设置rom的深度</span><br><span class="line">%---------------------------------%</span><br><span class="line"></span><br><span class="line">x=linspace(0,2*pi,depth);       %在一个周期内产生depth个采样点</span><br><span class="line">y_cos=cos(x);                   %生成余弦函数</span><br><span class="line">%y_cos=sin(x);                   %生成正弦函数</span><br><span class="line">%y_cos=round(y_cos*(2^(width-1)-1))+2^(width-1)-1;       %将数据转化成整数,生成无符号数</span><br><span class="line">y_cos=round(y_cos*(2^(width-1)-1));       %将数据转化成整数,生成有符号数</span><br><span class="line"></span><br><span class="line">plot(x,y_cos);                  %绘图</span><br><span class="line"></span><br><span class="line">fid = fopen(&apos;E:\Workspace\DDS\Design\IP_Core\cos.coe&apos;,&apos;wt&apos;);</span><br><span class="line"></span><br><span class="line">fprintf(fid,&apos;memory_initialization_radix = 10;\nmemory_initialization_vector = &apos;);</span><br><span class="line">for i = 1 : depth</span><br><span class="line">    if mod(i-1,8) == 0 </span><br><span class="line">        fprintf(fid,&apos;\n&apos;);</span><br><span class="line">    end</span><br><span class="line">    fprintf(fid,&apos;%6d,&apos;,y_cos(i));</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">fclose(fid);                    %关闭文件</span><br></pre></td></tr></table></figure><p>生成.coe文件后就可以进行IP核的配置了。</p><ul><li><strong>ROM核具体配置：</strong><br><img src="https://user-images.githubusercontent.com/29295862/35349621-6e1186ac-0176-11e8-98e5-a1475ff60d50.png" alt=" "><br><img src="https://user-images.githubusercontent.com/29295862/35349629-739fdf24-0176-11e8-800e-aea80c15a60d.png" alt=" "><br><img src="https://user-images.githubusercontent.com/29295862/35349637-77da1834-0176-11e8-8b3a-e1ce6b8441a5.png" alt=" "><br><img src="https://user-images.githubusercontent.com/29295862/35349644-7c3bb8ec-0176-11e8-9acc-f9033ad57396.png" alt=" "></li></ul><p>配置完IP核后，编写控制模块，产生两路信号。其中，调制信号上叠加的直流分量的大小为调制信号的峰值，这样将得到调制度为100%的已调信号。如果要得到不同的调制度，则需要叠加不同大小的直流分量，同时需要注意定义的数据位宽，防止数据溢出。</p><ul><li><strong>产生载波和带有直流分量的调制信号：</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">module cos_make(</span><br><span class="line">inputclk,</span><br><span class="line">inputrst_n,</span><br><span class="line">outputreg[7:0]cos_s,</span><br><span class="line">outputregsigned[7:0]cos_c</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">//------------------------------------//</span><br><span class="line">parameter freq_s = 32&apos;d429497;//调制信号频率10k</span><br><span class="line">parameter freq_c = 32&apos;d42949673;//载波频率1M</span><br><span class="line">parameter cnt_width = 8&apos;d32;</span><br><span class="line">//------------------------------------//</span><br><span class="line"></span><br><span class="line">//------------------------------------//</span><br><span class="line">reg [cnt_width-1:0]cnt_s = 0;</span><br><span class="line">reg[cnt_width-1:0]cnt_c = 0;</span><br><span class="line">wire [9:0]addr_s;</span><br><span class="line">wire[9:0]addr_c;</span><br><span class="line">always @(posedge clk or negedge rst_n) begin</span><br><span class="line">if(!rst_n)begin</span><br><span class="line">cnt_s &lt;= 0;</span><br><span class="line">cnt_c &lt;= 0;</span><br><span class="line">end</span><br><span class="line">elsebegin</span><br><span class="line">cnt_s &lt;= cnt_s + freq_s;</span><br><span class="line">cnt_c &lt;= cnt_c + freq_c;</span><br><span class="line">end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">assignaddr_s = cnt_s[cnt_width-1:cnt_width-10];</span><br><span class="line">assignaddr_c = cnt_c[cnt_width-1:cnt_width-10];</span><br><span class="line">//------------------------------------//</span><br><span class="line"></span><br><span class="line">//------------调用ROM核----------------//</span><br><span class="line">wire signed[7:0]cos_s_r;</span><br><span class="line">wire signed[7:0]cos_c_r;</span><br><span class="line"></span><br><span class="line">ROMROM_inst(</span><br><span class="line">.clka(clk),</span><br><span class="line">.addra(addr_s),</span><br><span class="line">.douta(cos_s_r),</span><br><span class="line">.clkb(clk),</span><br><span class="line">.addrb(addr_c),</span><br><span class="line">.doutb(cos_c_r)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">always @(posedge clk or negedge rst_n) begin</span><br><span class="line">if(!rst_n)begin</span><br><span class="line">cos_s &lt;= 0;</span><br><span class="line">cos_c &lt;= 0;</span><br><span class="line">end</span><br><span class="line">elsebegin</span><br><span class="line">cos_s &lt;= cos_s_r + 8 &apos;d128;//加上大小为峰值的直流分量</span><br><span class="line">cos_c &lt;= cos_c_r;</span><br><span class="line">end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><h3 id="2-生成AM调制信号"><a href="#2-生成AM调制信号" class="headerlink" title="2.生成AM调制信号"></a>2.生成AM调制信号</h3><p>得到两路信号后就可以用乘法器将两路信号相乘，得到已调信号。</p><ul><li><p><strong>乘法器具体配置：</strong><br><img src="https://user-images.githubusercontent.com/29295862/35351304-722b11ea-017b-11e8-8fbe-fa55d56b9e0c.png" alt=" "><br><img src="https://user-images.githubusercontent.com/29295862/35351309-76a5fee2-017b-11e8-876f-0c74fc15beab.png" alt=" "></p></li><li><p><strong>AM调制的顶层模块：</strong></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">module modulate(</span><br><span class="line">inputclk,</span><br><span class="line">inputrst_n,</span><br><span class="line">outputsigned[15:0]AM_mod</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">wire [7:0]cos_s;</span><br><span class="line">wiresigned[7:0]cos_c;</span><br><span class="line"></span><br><span class="line">//------------调用出波模块------------//</span><br><span class="line">cos_makecos_make_inst0(</span><br><span class="line">.clk(clk),</span><br><span class="line">.rst_n(rst_n),</span><br><span class="line">.cos_s(cos_s),</span><br><span class="line">.cos_c(cos_c)</span><br><span class="line">);</span><br><span class="line">//-----------------------------------//</span><br><span class="line"></span><br><span class="line">//------------调用乘法器--------------//</span><br><span class="line">MULTMULT_inst1(</span><br><span class="line">  .CLK(clk),</span><br><span class="line">  .A(cos_s),</span><br><span class="line">  .B(cos_c),</span><br><span class="line">  .P(AM_mod)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><h3 id="3-仿真调制结果"><a href="#3-仿真调制结果" class="headerlink" title="3.仿真调制结果"></a>3.仿真调制结果</h3><p>以上AM调制过程基本完成，但是正确与否还需要通过仿真来确定，接下来编写仿真用的测试模块。</p><ul><li><strong>TestBeach的编写：</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">`timescale 1ns/1ps</span><br><span class="line"></span><br><span class="line">module tb_AM();</span><br><span class="line"></span><br><span class="line">//---------接口设置----------//</span><br><span class="line">reg sclk;</span><br><span class="line">regrst_n;</span><br><span class="line">wire signed[15:0]AM_mod;</span><br><span class="line">//--------------------------//</span><br><span class="line">initialsclk = 1;</span><br><span class="line">always#5sclk = ~sclk;//100M时钟</span><br><span class="line"></span><br><span class="line">initialbegin</span><br><span class="line">rst_n = 0;</span><br><span class="line">#500</span><br><span class="line">rst_n = 1;</span><br><span class="line">end</span><br><span class="line">//--------------------------//</span><br><span class="line">modulatemodulate_inst0(</span><br><span class="line">.clk(sclk),</span><br><span class="line">.rst_n(rst_n),</span><br><span class="line">.AM_mod(AM_mod)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><p>在Vivado中将各个文件添加进工程后，运行仿真。</p><ul><li><strong>仿真结果如下：</strong><br><img src="https://user-images.githubusercontent.com/29295862/35352112-d7de9514-017d-11e8-8bfc-bb974be7840c.png" alt=" "><br><img src="https://user-images.githubusercontent.com/29295862/35352115-da652410-017d-11e8-8d84-881a1c2af51f.png" alt=" "></li></ul><p>已调信号能明显看到包络，并且包络的频率同调制信号一致，表明AM调制正确。</p>]]></content:encoded>
      
      <comments>https://DOOKNET.github.io/2018/02/09/AM%E8%B0%83%E5%88%B6%E7%9A%84FPGA%E5%AE%9E%E7%8E%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>关于博客</title>
      <link>https://DOOKNET.github.io/2018/02/06/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2/</link>
      <guid>https://DOOKNET.github.io/2018/02/06/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2/</guid>
      <pubDate>Tue, 06 Feb 2018 11:54:12 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;我的博客之路&quot;&gt;&lt;a href=&quot;#我的博客之路&quot; class=&quot;headerlink&quot; title=&quot;我的博客之路&quot;&gt;&lt;/a&gt;我的博客之路&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;种一棵树最好的时间是什么时候？  十年之前。&lt;/p&gt;
&lt;/blockquote&gt;

        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="我的博客之路"><a href="#我的博客之路" class="headerlink" title="我的博客之路"></a>我的博客之路</h2><blockquote><p>种一棵树最好的时间是什么时候？  十年之前。</p></blockquote><p>简单来说，我的博客之路主要分为以下几个阶段：</p><ul><li><p>第一阶段：<br>从刚接触博客到真正开始写博客经历了很长时间。我的第一篇博客是在博客园写的，在决定写博客之前收集了很多信息，包括在知乎，Google等上查如何写博客？为什么要写博客？在哪里写博客？之类的问题。犹豫了很久，才决定在博客园上写。</p></li><li><p>第二阶段：<br>在博客园上写了两篇不怎么样的博客后就很长一段时间都没在写博客，一方面是学业较忙，另一方面是确实没什么产出，因为一开始给自己博客的定位是技术类博客，所以不是干货也不愿意放博客上。后来一次偶然的机会，发现周围很多人都在CSDN，而那段时间正好用上了MarkDown，所以决定尝试用CSDN的MarkDown编辑器写博客，然后发现界面居然还挺好看的，体验真心不错，至少比博客园的编辑体验好多了（说实话，编辑体验确实很能影响写博客的心情），于是乎决定在CSDN常驻下来，曾一度以为这里是我的博客归属地了。</p></li><li><p>第三阶段：<br>随着时间的推移，慢慢的开始胡思乱想了，万一博客园和CSDN倒闭了怎么办，之前的文章不就都没了吗;把自己的心得、成果都放在别人家的网站上总感觉不太放心，总感觉不是属于自己的东西（原谅我奇怪的占有欲233）。于是萌生了利用GitHub搭建博客的想法，但又突然想到万一GitHub倒闭了或者被墙了怎么办？毕竟GitHub被墙比CSDN倒闭的可能性大多了。。。于是一个偶然的机会看到了开头的那句话。可以说，这句话是我开始动手建站的导火索。是啊，纠结是最弱智的行为。在经历了两个晚上的折腾之后终于搭建完了自己的博客。可以说是满满的成就感啊！</p></li></ul><p>目前我的写博客流程基本是这样的：</p><ul><li>在本地用MarkDown写完博客后推到<a href="https://DOOKNET.github.io">个人博客</a>，作为博客的出处。</li><li>将本地博客导入到<a href="http://blog.csdn.net/HOOKNET" target="_blank" rel="noopener">CSDN</a>进行发布。</li><li>将本地文件内容复制到<a href="http://www.cnblogs.com/HOOKNET" target="_blank" rel="noopener">博客园</a>进行发布。</li></ul><p>当然，平台什么的都是其次，主要是有产出，而这个博客站点的搭建也是为了激励我坚持写博客。</p><p>但行好事，莫问前程！</p>]]></content:encoded>
      
      <comments>https://DOOKNET.github.io/2018/02/06/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
